
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model BuletinTable
 * 
 */
export type BuletinTable = $Result.DefaultSelection<Prisma.$BuletinTablePayload>
/**
 * Model berita
 * 
 */
export type berita = $Result.DefaultSelection<Prisma.$beritaPayload>
/**
 * Model pegawai
 * 
 */
export type pegawai = $Result.DefaultSelection<Prisma.$pegawaiPayload>
/**
 * Model cuacahariini
 * 
 */
export type cuacahariini = $Result.DefaultSelection<Prisma.$cuacahariiniPayload>
/**
 * Model tourism
 * 
 */
export type tourism = $Result.DefaultSelection<Prisma.$tourismPayload>
/**
 * Model analisiscurahhujan
 * 
 */
export type analisiscurahhujan = $Result.DefaultSelection<Prisma.$analisiscurahhujanPayload>
/**
 * Model analisissifathujan
 * 
 */
export type analisissifathujan = $Result.DefaultSelection<Prisma.$analisissifathujanPayload>
/**
 * Model prakiraancurahhujan
 * 
 */
export type prakiraancurahhujan = $Result.DefaultSelection<Prisma.$prakiraancurahhujanPayload>
/**
 * Model haritanpahujan
 * 
 */
export type haritanpahujan = $Result.DefaultSelection<Prisma.$haritanpahujanPayload>
/**
 * Model normalmusim
 * 
 */
export type normalmusim = $Result.DefaultSelection<Prisma.$normalmusimPayload>
/**
 * Model kritiksaran
 * 
 */
export type kritiksaran = $Result.DefaultSelection<Prisma.$kritiksaranPayload>
/**
 * Model cuacabesok
 * 
 */
export type cuacabesok = $Result.DefaultSelection<Prisma.$cuacabesokPayload>
/**
 * Model peringatandini
 * 
 */
export type peringatandini = $Result.DefaultSelection<Prisma.$peringatandiniPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Images
 * const images = await prisma.image.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Images
   * const images = await prisma.image.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs>;

  /**
   * `prisma.buletinTable`: Exposes CRUD operations for the **BuletinTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuletinTables
    * const buletinTables = await prisma.buletinTable.findMany()
    * ```
    */
  get buletinTable(): Prisma.BuletinTableDelegate<ExtArgs>;

  /**
   * `prisma.berita`: Exposes CRUD operations for the **berita** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beritas
    * const beritas = await prisma.berita.findMany()
    * ```
    */
  get berita(): Prisma.beritaDelegate<ExtArgs>;

  /**
   * `prisma.pegawai`: Exposes CRUD operations for the **pegawai** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pegawais
    * const pegawais = await prisma.pegawai.findMany()
    * ```
    */
  get pegawai(): Prisma.pegawaiDelegate<ExtArgs>;

  /**
   * `prisma.cuacahariini`: Exposes CRUD operations for the **cuacahariini** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuacahariinis
    * const cuacahariinis = await prisma.cuacahariini.findMany()
    * ```
    */
  get cuacahariini(): Prisma.cuacahariiniDelegate<ExtArgs>;

  /**
   * `prisma.tourism`: Exposes CRUD operations for the **tourism** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tourisms
    * const tourisms = await prisma.tourism.findMany()
    * ```
    */
  get tourism(): Prisma.tourismDelegate<ExtArgs>;

  /**
   * `prisma.analisiscurahhujan`: Exposes CRUD operations for the **analisiscurahhujan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analisiscurahhujans
    * const analisiscurahhujans = await prisma.analisiscurahhujan.findMany()
    * ```
    */
  get analisiscurahhujan(): Prisma.analisiscurahhujanDelegate<ExtArgs>;

  /**
   * `prisma.analisissifathujan`: Exposes CRUD operations for the **analisissifathujan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analisissifathujans
    * const analisissifathujans = await prisma.analisissifathujan.findMany()
    * ```
    */
  get analisissifathujan(): Prisma.analisissifathujanDelegate<ExtArgs>;

  /**
   * `prisma.prakiraancurahhujan`: Exposes CRUD operations for the **prakiraancurahhujan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prakiraancurahhujans
    * const prakiraancurahhujans = await prisma.prakiraancurahhujan.findMany()
    * ```
    */
  get prakiraancurahhujan(): Prisma.prakiraancurahhujanDelegate<ExtArgs>;

  /**
   * `prisma.haritanpahujan`: Exposes CRUD operations for the **haritanpahujan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Haritanpahujans
    * const haritanpahujans = await prisma.haritanpahujan.findMany()
    * ```
    */
  get haritanpahujan(): Prisma.haritanpahujanDelegate<ExtArgs>;

  /**
   * `prisma.normalmusim`: Exposes CRUD operations for the **normalmusim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Normalmusims
    * const normalmusims = await prisma.normalmusim.findMany()
    * ```
    */
  get normalmusim(): Prisma.normalmusimDelegate<ExtArgs>;

  /**
   * `prisma.kritiksaran`: Exposes CRUD operations for the **kritiksaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kritiksarans
    * const kritiksarans = await prisma.kritiksaran.findMany()
    * ```
    */
  get kritiksaran(): Prisma.kritiksaranDelegate<ExtArgs>;

  /**
   * `prisma.cuacabesok`: Exposes CRUD operations for the **cuacabesok** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuacabesoks
    * const cuacabesoks = await prisma.cuacabesok.findMany()
    * ```
    */
  get cuacabesok(): Prisma.cuacabesokDelegate<ExtArgs>;

  /**
   * `prisma.peringatandini`: Exposes CRUD operations for the **peringatandini** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Peringatandinis
    * const peringatandinis = await prisma.peringatandini.findMany()
    * ```
    */
  get peringatandini(): Prisma.peringatandiniDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: e95e739751f42d8ca026f6b910f5a2dc5adeaeee
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Image: 'Image',
    BuletinTable: 'BuletinTable',
    berita: 'berita',
    pegawai: 'pegawai',
    cuacahariini: 'cuacahariini',
    tourism: 'tourism',
    analisiscurahhujan: 'analisiscurahhujan',
    analisissifathujan: 'analisissifathujan',
    prakiraancurahhujan: 'prakiraancurahhujan',
    haritanpahujan: 'haritanpahujan',
    normalmusim: 'normalmusim',
    kritiksaran: 'kritiksaran',
    cuacabesok: 'cuacabesok',
    peringatandini: 'peringatandini'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'image' | 'buletinTable' | 'berita' | 'pegawai' | 'cuacahariini' | 'tourism' | 'analisiscurahhujan' | 'analisissifathujan' | 'prakiraancurahhujan' | 'haritanpahujan' | 'normalmusim' | 'kritiksaran' | 'cuacabesok' | 'peringatandini'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>,
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      BuletinTable: {
        payload: Prisma.$BuletinTablePayload<ExtArgs>
        fields: Prisma.BuletinTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuletinTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuletinTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>
          }
          findFirst: {
            args: Prisma.BuletinTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuletinTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>
          }
          findMany: {
            args: Prisma.BuletinTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>[]
          }
          create: {
            args: Prisma.BuletinTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>
          }
          createMany: {
            args: Prisma.BuletinTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuletinTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>
          }
          update: {
            args: Prisma.BuletinTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>
          }
          deleteMany: {
            args: Prisma.BuletinTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuletinTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuletinTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuletinTablePayload>
          }
          aggregate: {
            args: Prisma.BuletinTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuletinTable>
          }
          groupBy: {
            args: Prisma.BuletinTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuletinTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuletinTableCountArgs<ExtArgs>,
            result: $Utils.Optional<BuletinTableCountAggregateOutputType> | number
          }
        }
      }
      berita: {
        payload: Prisma.$beritaPayload<ExtArgs>
        fields: Prisma.beritaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.beritaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.beritaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>
          }
          findFirst: {
            args: Prisma.beritaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.beritaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>
          }
          findMany: {
            args: Prisma.beritaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>[]
          }
          create: {
            args: Prisma.beritaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>
          }
          createMany: {
            args: Prisma.beritaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.beritaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>
          }
          update: {
            args: Prisma.beritaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>
          }
          deleteMany: {
            args: Prisma.beritaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.beritaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.beritaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$beritaPayload>
          }
          aggregate: {
            args: Prisma.BeritaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBerita>
          }
          groupBy: {
            args: Prisma.beritaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BeritaGroupByOutputType>[]
          }
          count: {
            args: Prisma.beritaCountArgs<ExtArgs>,
            result: $Utils.Optional<BeritaCountAggregateOutputType> | number
          }
        }
      }
      pegawai: {
        payload: Prisma.$pegawaiPayload<ExtArgs>
        fields: Prisma.pegawaiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pegawaiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pegawaiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>
          }
          findFirst: {
            args: Prisma.pegawaiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pegawaiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>
          }
          findMany: {
            args: Prisma.pegawaiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>[]
          }
          create: {
            args: Prisma.pegawaiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>
          }
          createMany: {
            args: Prisma.pegawaiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pegawaiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>
          }
          update: {
            args: Prisma.pegawaiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>
          }
          deleteMany: {
            args: Prisma.pegawaiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pegawaiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pegawaiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pegawaiPayload>
          }
          aggregate: {
            args: Prisma.PegawaiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePegawai>
          }
          groupBy: {
            args: Prisma.pegawaiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PegawaiGroupByOutputType>[]
          }
          count: {
            args: Prisma.pegawaiCountArgs<ExtArgs>,
            result: $Utils.Optional<PegawaiCountAggregateOutputType> | number
          }
        }
      }
      cuacahariini: {
        payload: Prisma.$cuacahariiniPayload<ExtArgs>
        fields: Prisma.cuacahariiniFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cuacahariiniFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cuacahariiniFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>
          }
          findFirst: {
            args: Prisma.cuacahariiniFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cuacahariiniFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>
          }
          findMany: {
            args: Prisma.cuacahariiniFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>[]
          }
          create: {
            args: Prisma.cuacahariiniCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>
          }
          createMany: {
            args: Prisma.cuacahariiniCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cuacahariiniDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>
          }
          update: {
            args: Prisma.cuacahariiniUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>
          }
          deleteMany: {
            args: Prisma.cuacahariiniDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cuacahariiniUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cuacahariiniUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacahariiniPayload>
          }
          aggregate: {
            args: Prisma.CuacahariiniAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCuacahariini>
          }
          groupBy: {
            args: Prisma.cuacahariiniGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CuacahariiniGroupByOutputType>[]
          }
          count: {
            args: Prisma.cuacahariiniCountArgs<ExtArgs>,
            result: $Utils.Optional<CuacahariiniCountAggregateOutputType> | number
          }
        }
      }
      tourism: {
        payload: Prisma.$tourismPayload<ExtArgs>
        fields: Prisma.tourismFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tourismFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tourismFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>
          }
          findFirst: {
            args: Prisma.tourismFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tourismFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>
          }
          findMany: {
            args: Prisma.tourismFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>[]
          }
          create: {
            args: Prisma.tourismCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>
          }
          createMany: {
            args: Prisma.tourismCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tourismDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>
          }
          update: {
            args: Prisma.tourismUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>
          }
          deleteMany: {
            args: Prisma.tourismDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tourismUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tourismUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tourismPayload>
          }
          aggregate: {
            args: Prisma.TourismAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTourism>
          }
          groupBy: {
            args: Prisma.tourismGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TourismGroupByOutputType>[]
          }
          count: {
            args: Prisma.tourismCountArgs<ExtArgs>,
            result: $Utils.Optional<TourismCountAggregateOutputType> | number
          }
        }
      }
      analisiscurahhujan: {
        payload: Prisma.$analisiscurahhujanPayload<ExtArgs>
        fields: Prisma.analisiscurahhujanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.analisiscurahhujanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.analisiscurahhujanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>
          }
          findFirst: {
            args: Prisma.analisiscurahhujanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.analisiscurahhujanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>
          }
          findMany: {
            args: Prisma.analisiscurahhujanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>[]
          }
          create: {
            args: Prisma.analisiscurahhujanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>
          }
          createMany: {
            args: Prisma.analisiscurahhujanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.analisiscurahhujanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>
          }
          update: {
            args: Prisma.analisiscurahhujanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>
          }
          deleteMany: {
            args: Prisma.analisiscurahhujanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.analisiscurahhujanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.analisiscurahhujanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisiscurahhujanPayload>
          }
          aggregate: {
            args: Prisma.AnalisiscurahhujanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnalisiscurahhujan>
          }
          groupBy: {
            args: Prisma.analisiscurahhujanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnalisiscurahhujanGroupByOutputType>[]
          }
          count: {
            args: Prisma.analisiscurahhujanCountArgs<ExtArgs>,
            result: $Utils.Optional<AnalisiscurahhujanCountAggregateOutputType> | number
          }
        }
      }
      analisissifathujan: {
        payload: Prisma.$analisissifathujanPayload<ExtArgs>
        fields: Prisma.analisissifathujanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.analisissifathujanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.analisissifathujanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>
          }
          findFirst: {
            args: Prisma.analisissifathujanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.analisissifathujanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>
          }
          findMany: {
            args: Prisma.analisissifathujanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>[]
          }
          create: {
            args: Prisma.analisissifathujanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>
          }
          createMany: {
            args: Prisma.analisissifathujanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.analisissifathujanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>
          }
          update: {
            args: Prisma.analisissifathujanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>
          }
          deleteMany: {
            args: Prisma.analisissifathujanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.analisissifathujanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.analisissifathujanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$analisissifathujanPayload>
          }
          aggregate: {
            args: Prisma.AnalisissifathujanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnalisissifathujan>
          }
          groupBy: {
            args: Prisma.analisissifathujanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnalisissifathujanGroupByOutputType>[]
          }
          count: {
            args: Prisma.analisissifathujanCountArgs<ExtArgs>,
            result: $Utils.Optional<AnalisissifathujanCountAggregateOutputType> | number
          }
        }
      }
      prakiraancurahhujan: {
        payload: Prisma.$prakiraancurahhujanPayload<ExtArgs>
        fields: Prisma.prakiraancurahhujanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prakiraancurahhujanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prakiraancurahhujanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>
          }
          findFirst: {
            args: Prisma.prakiraancurahhujanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prakiraancurahhujanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>
          }
          findMany: {
            args: Prisma.prakiraancurahhujanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>[]
          }
          create: {
            args: Prisma.prakiraancurahhujanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>
          }
          createMany: {
            args: Prisma.prakiraancurahhujanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.prakiraancurahhujanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>
          }
          update: {
            args: Prisma.prakiraancurahhujanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>
          }
          deleteMany: {
            args: Prisma.prakiraancurahhujanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.prakiraancurahhujanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.prakiraancurahhujanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$prakiraancurahhujanPayload>
          }
          aggregate: {
            args: Prisma.PrakiraancurahhujanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrakiraancurahhujan>
          }
          groupBy: {
            args: Prisma.prakiraancurahhujanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PrakiraancurahhujanGroupByOutputType>[]
          }
          count: {
            args: Prisma.prakiraancurahhujanCountArgs<ExtArgs>,
            result: $Utils.Optional<PrakiraancurahhujanCountAggregateOutputType> | number
          }
        }
      }
      haritanpahujan: {
        payload: Prisma.$haritanpahujanPayload<ExtArgs>
        fields: Prisma.haritanpahujanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.haritanpahujanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.haritanpahujanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>
          }
          findFirst: {
            args: Prisma.haritanpahujanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.haritanpahujanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>
          }
          findMany: {
            args: Prisma.haritanpahujanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>[]
          }
          create: {
            args: Prisma.haritanpahujanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>
          }
          createMany: {
            args: Prisma.haritanpahujanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.haritanpahujanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>
          }
          update: {
            args: Prisma.haritanpahujanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>
          }
          deleteMany: {
            args: Prisma.haritanpahujanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.haritanpahujanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.haritanpahujanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$haritanpahujanPayload>
          }
          aggregate: {
            args: Prisma.HaritanpahujanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHaritanpahujan>
          }
          groupBy: {
            args: Prisma.haritanpahujanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HaritanpahujanGroupByOutputType>[]
          }
          count: {
            args: Prisma.haritanpahujanCountArgs<ExtArgs>,
            result: $Utils.Optional<HaritanpahujanCountAggregateOutputType> | number
          }
        }
      }
      normalmusim: {
        payload: Prisma.$normalmusimPayload<ExtArgs>
        fields: Prisma.normalmusimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.normalmusimFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.normalmusimFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>
          }
          findFirst: {
            args: Prisma.normalmusimFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.normalmusimFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>
          }
          findMany: {
            args: Prisma.normalmusimFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>[]
          }
          create: {
            args: Prisma.normalmusimCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>
          }
          createMany: {
            args: Prisma.normalmusimCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.normalmusimDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>
          }
          update: {
            args: Prisma.normalmusimUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>
          }
          deleteMany: {
            args: Prisma.normalmusimDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.normalmusimUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.normalmusimUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$normalmusimPayload>
          }
          aggregate: {
            args: Prisma.NormalmusimAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNormalmusim>
          }
          groupBy: {
            args: Prisma.normalmusimGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NormalmusimGroupByOutputType>[]
          }
          count: {
            args: Prisma.normalmusimCountArgs<ExtArgs>,
            result: $Utils.Optional<NormalmusimCountAggregateOutputType> | number
          }
        }
      }
      kritiksaran: {
        payload: Prisma.$kritiksaranPayload<ExtArgs>
        fields: Prisma.kritiksaranFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kritiksaranFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kritiksaranFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>
          }
          findFirst: {
            args: Prisma.kritiksaranFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kritiksaranFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>
          }
          findMany: {
            args: Prisma.kritiksaranFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>[]
          }
          create: {
            args: Prisma.kritiksaranCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>
          }
          createMany: {
            args: Prisma.kritiksaranCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.kritiksaranDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>
          }
          update: {
            args: Prisma.kritiksaranUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>
          }
          deleteMany: {
            args: Prisma.kritiksaranDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.kritiksaranUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.kritiksaranUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$kritiksaranPayload>
          }
          aggregate: {
            args: Prisma.KritiksaranAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKritiksaran>
          }
          groupBy: {
            args: Prisma.kritiksaranGroupByArgs<ExtArgs>,
            result: $Utils.Optional<KritiksaranGroupByOutputType>[]
          }
          count: {
            args: Prisma.kritiksaranCountArgs<ExtArgs>,
            result: $Utils.Optional<KritiksaranCountAggregateOutputType> | number
          }
        }
      }
      cuacabesok: {
        payload: Prisma.$cuacabesokPayload<ExtArgs>
        fields: Prisma.cuacabesokFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cuacabesokFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cuacabesokFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>
          }
          findFirst: {
            args: Prisma.cuacabesokFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cuacabesokFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>
          }
          findMany: {
            args: Prisma.cuacabesokFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>[]
          }
          create: {
            args: Prisma.cuacabesokCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>
          }
          createMany: {
            args: Prisma.cuacabesokCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cuacabesokDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>
          }
          update: {
            args: Prisma.cuacabesokUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>
          }
          deleteMany: {
            args: Prisma.cuacabesokDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cuacabesokUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cuacabesokUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cuacabesokPayload>
          }
          aggregate: {
            args: Prisma.CuacabesokAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCuacabesok>
          }
          groupBy: {
            args: Prisma.cuacabesokGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CuacabesokGroupByOutputType>[]
          }
          count: {
            args: Prisma.cuacabesokCountArgs<ExtArgs>,
            result: $Utils.Optional<CuacabesokCountAggregateOutputType> | number
          }
        }
      }
      peringatandini: {
        payload: Prisma.$peringatandiniPayload<ExtArgs>
        fields: Prisma.peringatandiniFieldRefs
        operations: {
          findUnique: {
            args: Prisma.peringatandiniFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.peringatandiniFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>
          }
          findFirst: {
            args: Prisma.peringatandiniFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.peringatandiniFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>
          }
          findMany: {
            args: Prisma.peringatandiniFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>[]
          }
          create: {
            args: Prisma.peringatandiniCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>
          }
          createMany: {
            args: Prisma.peringatandiniCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.peringatandiniDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>
          }
          update: {
            args: Prisma.peringatandiniUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>
          }
          deleteMany: {
            args: Prisma.peringatandiniDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.peringatandiniUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.peringatandiniUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$peringatandiniPayload>
          }
          aggregate: {
            args: Prisma.PeringatandiniAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePeringatandini>
          }
          groupBy: {
            args: Prisma.peringatandiniGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PeringatandiniGroupByOutputType>[]
          }
          count: {
            args: Prisma.peringatandiniCountArgs<ExtArgs>,
            result: $Utils.Optional<PeringatandiniCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    name: string | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: number
    name: string
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["image"]>
    composites: {}
  }


  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ImageCreateArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Images.
     *     @param {ImageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>
    ): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Image model
   */ 
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'Int'>
    readonly name: FieldRef<"Image", 'String'>
    readonly foto: FieldRef<"Image", 'String'>
    readonly url: FieldRef<"Image", 'String'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }


  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }


  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }


  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }


  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
  }



  /**
   * Model BuletinTable
   */

  export type AggregateBuletinTable = {
    _count: BuletinTableCountAggregateOutputType | null
    _avg: BuletinTableAvgAggregateOutputType | null
    _sum: BuletinTableSumAggregateOutputType | null
    _min: BuletinTableMinAggregateOutputType | null
    _max: BuletinTableMaxAggregateOutputType | null
  }

  export type BuletinTableAvgAggregateOutputType = {
    id: number | null
  }

  export type BuletinTableSumAggregateOutputType = {
    id: number | null
  }

  export type BuletinTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    buletin: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuletinTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    buletin: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuletinTableCountAggregateOutputType = {
    id: number
    name: number
    buletin: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuletinTableAvgAggregateInputType = {
    id?: true
  }

  export type BuletinTableSumAggregateInputType = {
    id?: true
  }

  export type BuletinTableMinAggregateInputType = {
    id?: true
    name?: true
    buletin?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuletinTableMaxAggregateInputType = {
    id?: true
    name?: true
    buletin?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuletinTableCountAggregateInputType = {
    id?: true
    name?: true
    buletin?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuletinTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuletinTable to aggregate.
     */
    where?: BuletinTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuletinTables to fetch.
     */
    orderBy?: BuletinTableOrderByWithRelationInput | BuletinTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuletinTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuletinTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuletinTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuletinTables
    **/
    _count?: true | BuletinTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuletinTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuletinTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuletinTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuletinTableMaxAggregateInputType
  }

  export type GetBuletinTableAggregateType<T extends BuletinTableAggregateArgs> = {
        [P in keyof T & keyof AggregateBuletinTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuletinTable[P]>
      : GetScalarType<T[P], AggregateBuletinTable[P]>
  }




  export type BuletinTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuletinTableWhereInput
    orderBy?: BuletinTableOrderByWithAggregationInput | BuletinTableOrderByWithAggregationInput[]
    by: BuletinTableScalarFieldEnum[] | BuletinTableScalarFieldEnum
    having?: BuletinTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuletinTableCountAggregateInputType | true
    _avg?: BuletinTableAvgAggregateInputType
    _sum?: BuletinTableSumAggregateInputType
    _min?: BuletinTableMinAggregateInputType
    _max?: BuletinTableMaxAggregateInputType
  }

  export type BuletinTableGroupByOutputType = {
    id: number
    name: string
    buletin: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: BuletinTableCountAggregateOutputType | null
    _avg: BuletinTableAvgAggregateOutputType | null
    _sum: BuletinTableSumAggregateOutputType | null
    _min: BuletinTableMinAggregateOutputType | null
    _max: BuletinTableMaxAggregateOutputType | null
  }

  type GetBuletinTableGroupByPayload<T extends BuletinTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuletinTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuletinTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuletinTableGroupByOutputType[P]>
            : GetScalarType<T[P], BuletinTableGroupByOutputType[P]>
        }
      >
    >


  export type BuletinTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buletin?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buletinTable"]>

  export type BuletinTableSelectScalar = {
    id?: boolean
    name?: boolean
    buletin?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BuletinTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuletinTable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      buletin: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buletinTable"]>
    composites: {}
  }


  type BuletinTableGetPayload<S extends boolean | null | undefined | BuletinTableDefaultArgs> = $Result.GetResult<Prisma.$BuletinTablePayload, S>

  type BuletinTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuletinTableFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuletinTableCountAggregateInputType | true
    }

  export interface BuletinTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuletinTable'], meta: { name: 'BuletinTable' } }
    /**
     * Find zero or one BuletinTable that matches the filter.
     * @param {BuletinTableFindUniqueArgs} args - Arguments to find a BuletinTable
     * @example
     * // Get one BuletinTable
     * const buletinTable = await prisma.buletinTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuletinTableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuletinTableFindUniqueArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuletinTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuletinTableFindUniqueOrThrowArgs} args - Arguments to find a BuletinTable
     * @example
     * // Get one BuletinTable
     * const buletinTable = await prisma.buletinTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuletinTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuletinTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuletinTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableFindFirstArgs} args - Arguments to find a BuletinTable
     * @example
     * // Get one BuletinTable
     * const buletinTable = await prisma.buletinTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuletinTableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuletinTableFindFirstArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuletinTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableFindFirstOrThrowArgs} args - Arguments to find a BuletinTable
     * @example
     * // Get one BuletinTable
     * const buletinTable = await prisma.buletinTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuletinTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuletinTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuletinTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuletinTables
     * const buletinTables = await prisma.buletinTable.findMany()
     * 
     * // Get first 10 BuletinTables
     * const buletinTables = await prisma.buletinTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buletinTableWithIdOnly = await prisma.buletinTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuletinTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuletinTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuletinTable.
     * @param {BuletinTableCreateArgs} args - Arguments to create a BuletinTable.
     * @example
     * // Create one BuletinTable
     * const BuletinTable = await prisma.buletinTable.create({
     *   data: {
     *     // ... data to create a BuletinTable
     *   }
     * })
     * 
    **/
    create<T extends BuletinTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuletinTableCreateArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuletinTables.
     *     @param {BuletinTableCreateManyArgs} args - Arguments to create many BuletinTables.
     *     @example
     *     // Create many BuletinTables
     *     const buletinTable = await prisma.buletinTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuletinTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuletinTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuletinTable.
     * @param {BuletinTableDeleteArgs} args - Arguments to delete one BuletinTable.
     * @example
     * // Delete one BuletinTable
     * const BuletinTable = await prisma.buletinTable.delete({
     *   where: {
     *     // ... filter to delete one BuletinTable
     *   }
     * })
     * 
    **/
    delete<T extends BuletinTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuletinTableDeleteArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuletinTable.
     * @param {BuletinTableUpdateArgs} args - Arguments to update one BuletinTable.
     * @example
     * // Update one BuletinTable
     * const buletinTable = await prisma.buletinTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuletinTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuletinTableUpdateArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuletinTables.
     * @param {BuletinTableDeleteManyArgs} args - Arguments to filter BuletinTables to delete.
     * @example
     * // Delete a few BuletinTables
     * const { count } = await prisma.buletinTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuletinTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuletinTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuletinTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuletinTables
     * const buletinTable = await prisma.buletinTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuletinTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuletinTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuletinTable.
     * @param {BuletinTableUpsertArgs} args - Arguments to update or create a BuletinTable.
     * @example
     * // Update or create a BuletinTable
     * const buletinTable = await prisma.buletinTable.upsert({
     *   create: {
     *     // ... data to create a BuletinTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuletinTable we want to update
     *   }
     * })
    **/
    upsert<T extends BuletinTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuletinTableUpsertArgs<ExtArgs>>
    ): Prisma__BuletinTableClient<$Result.GetResult<Prisma.$BuletinTablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuletinTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableCountArgs} args - Arguments to filter BuletinTables to count.
     * @example
     * // Count the number of BuletinTables
     * const count = await prisma.buletinTable.count({
     *   where: {
     *     // ... the filter for the BuletinTables we want to count
     *   }
     * })
    **/
    count<T extends BuletinTableCountArgs>(
      args?: Subset<T, BuletinTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuletinTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuletinTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuletinTableAggregateArgs>(args: Subset<T, BuletinTableAggregateArgs>): Prisma.PrismaPromise<GetBuletinTableAggregateType<T>>

    /**
     * Group by BuletinTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuletinTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuletinTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuletinTableGroupByArgs['orderBy'] }
        : { orderBy?: BuletinTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuletinTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuletinTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuletinTable model
   */
  readonly fields: BuletinTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuletinTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuletinTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuletinTable model
   */ 
  interface BuletinTableFieldRefs {
    readonly id: FieldRef<"BuletinTable", 'Int'>
    readonly name: FieldRef<"BuletinTable", 'String'>
    readonly buletin: FieldRef<"BuletinTable", 'String'>
    readonly url: FieldRef<"BuletinTable", 'String'>
    readonly createdAt: FieldRef<"BuletinTable", 'DateTime'>
    readonly updatedAt: FieldRef<"BuletinTable", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BuletinTable findUnique
   */
  export type BuletinTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * Filter, which BuletinTable to fetch.
     */
    where: BuletinTableWhereUniqueInput
  }


  /**
   * BuletinTable findUniqueOrThrow
   */
  export type BuletinTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * Filter, which BuletinTable to fetch.
     */
    where: BuletinTableWhereUniqueInput
  }


  /**
   * BuletinTable findFirst
   */
  export type BuletinTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * Filter, which BuletinTable to fetch.
     */
    where?: BuletinTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuletinTables to fetch.
     */
    orderBy?: BuletinTableOrderByWithRelationInput | BuletinTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuletinTables.
     */
    cursor?: BuletinTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuletinTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuletinTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuletinTables.
     */
    distinct?: BuletinTableScalarFieldEnum | BuletinTableScalarFieldEnum[]
  }


  /**
   * BuletinTable findFirstOrThrow
   */
  export type BuletinTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * Filter, which BuletinTable to fetch.
     */
    where?: BuletinTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuletinTables to fetch.
     */
    orderBy?: BuletinTableOrderByWithRelationInput | BuletinTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuletinTables.
     */
    cursor?: BuletinTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuletinTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuletinTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuletinTables.
     */
    distinct?: BuletinTableScalarFieldEnum | BuletinTableScalarFieldEnum[]
  }


  /**
   * BuletinTable findMany
   */
  export type BuletinTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * Filter, which BuletinTables to fetch.
     */
    where?: BuletinTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuletinTables to fetch.
     */
    orderBy?: BuletinTableOrderByWithRelationInput | BuletinTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuletinTables.
     */
    cursor?: BuletinTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuletinTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuletinTables.
     */
    skip?: number
    distinct?: BuletinTableScalarFieldEnum | BuletinTableScalarFieldEnum[]
  }


  /**
   * BuletinTable create
   */
  export type BuletinTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * The data needed to create a BuletinTable.
     */
    data: XOR<BuletinTableCreateInput, BuletinTableUncheckedCreateInput>
  }


  /**
   * BuletinTable createMany
   */
  export type BuletinTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuletinTables.
     */
    data: BuletinTableCreateManyInput | BuletinTableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BuletinTable update
   */
  export type BuletinTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * The data needed to update a BuletinTable.
     */
    data: XOR<BuletinTableUpdateInput, BuletinTableUncheckedUpdateInput>
    /**
     * Choose, which BuletinTable to update.
     */
    where: BuletinTableWhereUniqueInput
  }


  /**
   * BuletinTable updateMany
   */
  export type BuletinTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuletinTables.
     */
    data: XOR<BuletinTableUpdateManyMutationInput, BuletinTableUncheckedUpdateManyInput>
    /**
     * Filter which BuletinTables to update
     */
    where?: BuletinTableWhereInput
  }


  /**
   * BuletinTable upsert
   */
  export type BuletinTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * The filter to search for the BuletinTable to update in case it exists.
     */
    where: BuletinTableWhereUniqueInput
    /**
     * In case the BuletinTable found by the `where` argument doesn't exist, create a new BuletinTable with this data.
     */
    create: XOR<BuletinTableCreateInput, BuletinTableUncheckedCreateInput>
    /**
     * In case the BuletinTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuletinTableUpdateInput, BuletinTableUncheckedUpdateInput>
  }


  /**
   * BuletinTable delete
   */
  export type BuletinTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
    /**
     * Filter which BuletinTable to delete.
     */
    where: BuletinTableWhereUniqueInput
  }


  /**
   * BuletinTable deleteMany
   */
  export type BuletinTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuletinTables to delete
     */
    where?: BuletinTableWhereInput
  }


  /**
   * BuletinTable without action
   */
  export type BuletinTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuletinTable
     */
    select?: BuletinTableSelect<ExtArgs> | null
  }



  /**
   * Model berita
   */

  export type AggregateBerita = {
    _count: BeritaCountAggregateOutputType | null
    _avg: BeritaAvgAggregateOutputType | null
    _sum: BeritaSumAggregateOutputType | null
    _min: BeritaMinAggregateOutputType | null
    _max: BeritaMaxAggregateOutputType | null
  }

  export type BeritaAvgAggregateOutputType = {
    id: number | null
  }

  export type BeritaSumAggregateOutputType = {
    id: number | null
  }

  export type BeritaMinAggregateOutputType = {
    id: number | null
    judul: string | null
    tanggal: Date | null
    isi: string | null
    gambar: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BeritaMaxAggregateOutputType = {
    id: number | null
    judul: string | null
    tanggal: Date | null
    isi: string | null
    gambar: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BeritaCountAggregateOutputType = {
    id: number
    judul: number
    tanggal: number
    isi: number
    gambar: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BeritaAvgAggregateInputType = {
    id?: true
  }

  export type BeritaSumAggregateInputType = {
    id?: true
  }

  export type BeritaMinAggregateInputType = {
    id?: true
    judul?: true
    tanggal?: true
    isi?: true
    gambar?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BeritaMaxAggregateInputType = {
    id?: true
    judul?: true
    tanggal?: true
    isi?: true
    gambar?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BeritaCountAggregateInputType = {
    id?: true
    judul?: true
    tanggal?: true
    isi?: true
    gambar?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BeritaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which berita to aggregate.
     */
    where?: beritaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beritas to fetch.
     */
    orderBy?: beritaOrderByWithRelationInput | beritaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: beritaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beritas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beritas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned beritas
    **/
    _count?: true | BeritaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeritaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeritaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeritaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeritaMaxAggregateInputType
  }

  export type GetBeritaAggregateType<T extends BeritaAggregateArgs> = {
        [P in keyof T & keyof AggregateBerita]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBerita[P]>
      : GetScalarType<T[P], AggregateBerita[P]>
  }




  export type beritaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beritaWhereInput
    orderBy?: beritaOrderByWithAggregationInput | beritaOrderByWithAggregationInput[]
    by: BeritaScalarFieldEnum[] | BeritaScalarFieldEnum
    having?: beritaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeritaCountAggregateInputType | true
    _avg?: BeritaAvgAggregateInputType
    _sum?: BeritaSumAggregateInputType
    _min?: BeritaMinAggregateInputType
    _max?: BeritaMaxAggregateInputType
  }

  export type BeritaGroupByOutputType = {
    id: number
    judul: string
    tanggal: Date
    isi: string
    gambar: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: BeritaCountAggregateOutputType | null
    _avg: BeritaAvgAggregateOutputType | null
    _sum: BeritaSumAggregateOutputType | null
    _min: BeritaMinAggregateOutputType | null
    _max: BeritaMaxAggregateOutputType | null
  }

  type GetBeritaGroupByPayload<T extends beritaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeritaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeritaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeritaGroupByOutputType[P]>
            : GetScalarType<T[P], BeritaGroupByOutputType[P]>
        }
      >
    >


  export type beritaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    judul?: boolean
    tanggal?: boolean
    isi?: boolean
    gambar?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["berita"]>

  export type beritaSelectScalar = {
    id?: boolean
    judul?: boolean
    tanggal?: boolean
    isi?: boolean
    gambar?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $beritaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "berita"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      judul: string
      tanggal: Date
      isi: string
      gambar: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["berita"]>
    composites: {}
  }


  type beritaGetPayload<S extends boolean | null | undefined | beritaDefaultArgs> = $Result.GetResult<Prisma.$beritaPayload, S>

  type beritaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<beritaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BeritaCountAggregateInputType | true
    }

  export interface beritaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['berita'], meta: { name: 'berita' } }
    /**
     * Find zero or one Berita that matches the filter.
     * @param {beritaFindUniqueArgs} args - Arguments to find a Berita
     * @example
     * // Get one Berita
     * const berita = await prisma.berita.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends beritaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, beritaFindUniqueArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Berita that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {beritaFindUniqueOrThrowArgs} args - Arguments to find a Berita
     * @example
     * // Get one Berita
     * const berita = await prisma.berita.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends beritaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, beritaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Berita that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beritaFindFirstArgs} args - Arguments to find a Berita
     * @example
     * // Get one Berita
     * const berita = await prisma.berita.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends beritaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, beritaFindFirstArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Berita that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beritaFindFirstOrThrowArgs} args - Arguments to find a Berita
     * @example
     * // Get one Berita
     * const berita = await prisma.berita.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends beritaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, beritaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Beritas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beritaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beritas
     * const beritas = await prisma.berita.findMany()
     * 
     * // Get first 10 Beritas
     * const beritas = await prisma.berita.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beritaWithIdOnly = await prisma.berita.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends beritaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, beritaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Berita.
     * @param {beritaCreateArgs} args - Arguments to create a Berita.
     * @example
     * // Create one Berita
     * const Berita = await prisma.berita.create({
     *   data: {
     *     // ... data to create a Berita
     *   }
     * })
     * 
    **/
    create<T extends beritaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, beritaCreateArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Beritas.
     *     @param {beritaCreateManyArgs} args - Arguments to create many Beritas.
     *     @example
     *     // Create many Beritas
     *     const berita = await prisma.berita.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends beritaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, beritaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Berita.
     * @param {beritaDeleteArgs} args - Arguments to delete one Berita.
     * @example
     * // Delete one Berita
     * const Berita = await prisma.berita.delete({
     *   where: {
     *     // ... filter to delete one Berita
     *   }
     * })
     * 
    **/
    delete<T extends beritaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, beritaDeleteArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Berita.
     * @param {beritaUpdateArgs} args - Arguments to update one Berita.
     * @example
     * // Update one Berita
     * const berita = await prisma.berita.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends beritaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, beritaUpdateArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Beritas.
     * @param {beritaDeleteManyArgs} args - Arguments to filter Beritas to delete.
     * @example
     * // Delete a few Beritas
     * const { count } = await prisma.berita.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends beritaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, beritaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beritas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beritaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beritas
     * const berita = await prisma.berita.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends beritaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, beritaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Berita.
     * @param {beritaUpsertArgs} args - Arguments to update or create a Berita.
     * @example
     * // Update or create a Berita
     * const berita = await prisma.berita.upsert({
     *   create: {
     *     // ... data to create a Berita
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Berita we want to update
     *   }
     * })
    **/
    upsert<T extends beritaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, beritaUpsertArgs<ExtArgs>>
    ): Prisma__beritaClient<$Result.GetResult<Prisma.$beritaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Beritas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beritaCountArgs} args - Arguments to filter Beritas to count.
     * @example
     * // Count the number of Beritas
     * const count = await prisma.berita.count({
     *   where: {
     *     // ... the filter for the Beritas we want to count
     *   }
     * })
    **/
    count<T extends beritaCountArgs>(
      args?: Subset<T, beritaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeritaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Berita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeritaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeritaAggregateArgs>(args: Subset<T, BeritaAggregateArgs>): Prisma.PrismaPromise<GetBeritaAggregateType<T>>

    /**
     * Group by Berita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beritaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends beritaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: beritaGroupByArgs['orderBy'] }
        : { orderBy?: beritaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, beritaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeritaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the berita model
   */
  readonly fields: beritaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for berita.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__beritaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the berita model
   */ 
  interface beritaFieldRefs {
    readonly id: FieldRef<"berita", 'Int'>
    readonly judul: FieldRef<"berita", 'String'>
    readonly tanggal: FieldRef<"berita", 'DateTime'>
    readonly isi: FieldRef<"berita", 'String'>
    readonly gambar: FieldRef<"berita", 'String'>
    readonly url: FieldRef<"berita", 'String'>
    readonly createdAt: FieldRef<"berita", 'DateTime'>
    readonly updatedAt: FieldRef<"berita", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * berita findUnique
   */
  export type beritaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * Filter, which berita to fetch.
     */
    where: beritaWhereUniqueInput
  }


  /**
   * berita findUniqueOrThrow
   */
  export type beritaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * Filter, which berita to fetch.
     */
    where: beritaWhereUniqueInput
  }


  /**
   * berita findFirst
   */
  export type beritaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * Filter, which berita to fetch.
     */
    where?: beritaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beritas to fetch.
     */
    orderBy?: beritaOrderByWithRelationInput | beritaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beritas.
     */
    cursor?: beritaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beritas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beritas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beritas.
     */
    distinct?: BeritaScalarFieldEnum | BeritaScalarFieldEnum[]
  }


  /**
   * berita findFirstOrThrow
   */
  export type beritaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * Filter, which berita to fetch.
     */
    where?: beritaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beritas to fetch.
     */
    orderBy?: beritaOrderByWithRelationInput | beritaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beritas.
     */
    cursor?: beritaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beritas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beritas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beritas.
     */
    distinct?: BeritaScalarFieldEnum | BeritaScalarFieldEnum[]
  }


  /**
   * berita findMany
   */
  export type beritaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * Filter, which beritas to fetch.
     */
    where?: beritaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beritas to fetch.
     */
    orderBy?: beritaOrderByWithRelationInput | beritaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing beritas.
     */
    cursor?: beritaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beritas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beritas.
     */
    skip?: number
    distinct?: BeritaScalarFieldEnum | BeritaScalarFieldEnum[]
  }


  /**
   * berita create
   */
  export type beritaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * The data needed to create a berita.
     */
    data: XOR<beritaCreateInput, beritaUncheckedCreateInput>
  }


  /**
   * berita createMany
   */
  export type beritaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many beritas.
     */
    data: beritaCreateManyInput | beritaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * berita update
   */
  export type beritaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * The data needed to update a berita.
     */
    data: XOR<beritaUpdateInput, beritaUncheckedUpdateInput>
    /**
     * Choose, which berita to update.
     */
    where: beritaWhereUniqueInput
  }


  /**
   * berita updateMany
   */
  export type beritaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update beritas.
     */
    data: XOR<beritaUpdateManyMutationInput, beritaUncheckedUpdateManyInput>
    /**
     * Filter which beritas to update
     */
    where?: beritaWhereInput
  }


  /**
   * berita upsert
   */
  export type beritaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * The filter to search for the berita to update in case it exists.
     */
    where: beritaWhereUniqueInput
    /**
     * In case the berita found by the `where` argument doesn't exist, create a new berita with this data.
     */
    create: XOR<beritaCreateInput, beritaUncheckedCreateInput>
    /**
     * In case the berita was found with the provided `where` argument, update it with this data.
     */
    update: XOR<beritaUpdateInput, beritaUncheckedUpdateInput>
  }


  /**
   * berita delete
   */
  export type beritaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
    /**
     * Filter which berita to delete.
     */
    where: beritaWhereUniqueInput
  }


  /**
   * berita deleteMany
   */
  export type beritaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beritas to delete
     */
    where?: beritaWhereInput
  }


  /**
   * berita without action
   */
  export type beritaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the berita
     */
    select?: beritaSelect<ExtArgs> | null
  }



  /**
   * Model pegawai
   */

  export type AggregatePegawai = {
    _count: PegawaiCountAggregateOutputType | null
    _avg: PegawaiAvgAggregateOutputType | null
    _sum: PegawaiSumAggregateOutputType | null
    _min: PegawaiMinAggregateOutputType | null
    _max: PegawaiMaxAggregateOutputType | null
  }

  export type PegawaiAvgAggregateOutputType = {
    id: number | null
  }

  export type PegawaiSumAggregateOutputType = {
    id: number | null
  }

  export type PegawaiMinAggregateOutputType = {
    id: number | null
    nama: string | null
    nip: string | null
    pangkat: string | null
    jabatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PegawaiMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    nip: string | null
    pangkat: string | null
    jabatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PegawaiCountAggregateOutputType = {
    id: number
    nama: number
    nip: number
    pangkat: number
    jabatan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PegawaiAvgAggregateInputType = {
    id?: true
  }

  export type PegawaiSumAggregateInputType = {
    id?: true
  }

  export type PegawaiMinAggregateInputType = {
    id?: true
    nama?: true
    nip?: true
    pangkat?: true
    jabatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PegawaiMaxAggregateInputType = {
    id?: true
    nama?: true
    nip?: true
    pangkat?: true
    jabatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PegawaiCountAggregateInputType = {
    id?: true
    nama?: true
    nip?: true
    pangkat?: true
    jabatan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PegawaiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pegawai to aggregate.
     */
    where?: pegawaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pegawais to fetch.
     */
    orderBy?: pegawaiOrderByWithRelationInput | pegawaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pegawaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pegawais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pegawais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pegawais
    **/
    _count?: true | PegawaiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PegawaiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PegawaiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PegawaiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PegawaiMaxAggregateInputType
  }

  export type GetPegawaiAggregateType<T extends PegawaiAggregateArgs> = {
        [P in keyof T & keyof AggregatePegawai]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePegawai[P]>
      : GetScalarType<T[P], AggregatePegawai[P]>
  }




  export type pegawaiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pegawaiWhereInput
    orderBy?: pegawaiOrderByWithAggregationInput | pegawaiOrderByWithAggregationInput[]
    by: PegawaiScalarFieldEnum[] | PegawaiScalarFieldEnum
    having?: pegawaiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PegawaiCountAggregateInputType | true
    _avg?: PegawaiAvgAggregateInputType
    _sum?: PegawaiSumAggregateInputType
    _min?: PegawaiMinAggregateInputType
    _max?: PegawaiMaxAggregateInputType
  }

  export type PegawaiGroupByOutputType = {
    id: number
    nama: string
    nip: string
    pangkat: string
    jabatan: string
    createdAt: Date
    updatedAt: Date
    _count: PegawaiCountAggregateOutputType | null
    _avg: PegawaiAvgAggregateOutputType | null
    _sum: PegawaiSumAggregateOutputType | null
    _min: PegawaiMinAggregateOutputType | null
    _max: PegawaiMaxAggregateOutputType | null
  }

  type GetPegawaiGroupByPayload<T extends pegawaiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PegawaiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PegawaiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PegawaiGroupByOutputType[P]>
            : GetScalarType<T[P], PegawaiGroupByOutputType[P]>
        }
      >
    >


  export type pegawaiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    nip?: boolean
    pangkat?: boolean
    jabatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pegawai"]>

  export type pegawaiSelectScalar = {
    id?: boolean
    nama?: boolean
    nip?: boolean
    pangkat?: boolean
    jabatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $pegawaiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pegawai"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      nip: string
      pangkat: string
      jabatan: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pegawai"]>
    composites: {}
  }


  type pegawaiGetPayload<S extends boolean | null | undefined | pegawaiDefaultArgs> = $Result.GetResult<Prisma.$pegawaiPayload, S>

  type pegawaiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pegawaiFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PegawaiCountAggregateInputType | true
    }

  export interface pegawaiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pegawai'], meta: { name: 'pegawai' } }
    /**
     * Find zero or one Pegawai that matches the filter.
     * @param {pegawaiFindUniqueArgs} args - Arguments to find a Pegawai
     * @example
     * // Get one Pegawai
     * const pegawai = await prisma.pegawai.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pegawaiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pegawaiFindUniqueArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pegawai that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pegawaiFindUniqueOrThrowArgs} args - Arguments to find a Pegawai
     * @example
     * // Get one Pegawai
     * const pegawai = await prisma.pegawai.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pegawaiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pegawaiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pegawai that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pegawaiFindFirstArgs} args - Arguments to find a Pegawai
     * @example
     * // Get one Pegawai
     * const pegawai = await prisma.pegawai.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pegawaiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pegawaiFindFirstArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pegawai that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pegawaiFindFirstOrThrowArgs} args - Arguments to find a Pegawai
     * @example
     * // Get one Pegawai
     * const pegawai = await prisma.pegawai.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pegawaiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pegawaiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pegawais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pegawaiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pegawais
     * const pegawais = await prisma.pegawai.findMany()
     * 
     * // Get first 10 Pegawais
     * const pegawais = await prisma.pegawai.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pegawaiWithIdOnly = await prisma.pegawai.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pegawaiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pegawaiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pegawai.
     * @param {pegawaiCreateArgs} args - Arguments to create a Pegawai.
     * @example
     * // Create one Pegawai
     * const Pegawai = await prisma.pegawai.create({
     *   data: {
     *     // ... data to create a Pegawai
     *   }
     * })
     * 
    **/
    create<T extends pegawaiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pegawaiCreateArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pegawais.
     *     @param {pegawaiCreateManyArgs} args - Arguments to create many Pegawais.
     *     @example
     *     // Create many Pegawais
     *     const pegawai = await prisma.pegawai.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pegawaiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pegawaiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pegawai.
     * @param {pegawaiDeleteArgs} args - Arguments to delete one Pegawai.
     * @example
     * // Delete one Pegawai
     * const Pegawai = await prisma.pegawai.delete({
     *   where: {
     *     // ... filter to delete one Pegawai
     *   }
     * })
     * 
    **/
    delete<T extends pegawaiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pegawaiDeleteArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pegawai.
     * @param {pegawaiUpdateArgs} args - Arguments to update one Pegawai.
     * @example
     * // Update one Pegawai
     * const pegawai = await prisma.pegawai.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pegawaiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pegawaiUpdateArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pegawais.
     * @param {pegawaiDeleteManyArgs} args - Arguments to filter Pegawais to delete.
     * @example
     * // Delete a few Pegawais
     * const { count } = await prisma.pegawai.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pegawaiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pegawaiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pegawais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pegawaiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pegawais
     * const pegawai = await prisma.pegawai.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pegawaiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pegawaiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pegawai.
     * @param {pegawaiUpsertArgs} args - Arguments to update or create a Pegawai.
     * @example
     * // Update or create a Pegawai
     * const pegawai = await prisma.pegawai.upsert({
     *   create: {
     *     // ... data to create a Pegawai
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pegawai we want to update
     *   }
     * })
    **/
    upsert<T extends pegawaiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pegawaiUpsertArgs<ExtArgs>>
    ): Prisma__pegawaiClient<$Result.GetResult<Prisma.$pegawaiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pegawais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pegawaiCountArgs} args - Arguments to filter Pegawais to count.
     * @example
     * // Count the number of Pegawais
     * const count = await prisma.pegawai.count({
     *   where: {
     *     // ... the filter for the Pegawais we want to count
     *   }
     * })
    **/
    count<T extends pegawaiCountArgs>(
      args?: Subset<T, pegawaiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PegawaiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pegawai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PegawaiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PegawaiAggregateArgs>(args: Subset<T, PegawaiAggregateArgs>): Prisma.PrismaPromise<GetPegawaiAggregateType<T>>

    /**
     * Group by Pegawai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pegawaiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pegawaiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pegawaiGroupByArgs['orderBy'] }
        : { orderBy?: pegawaiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pegawaiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPegawaiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pegawai model
   */
  readonly fields: pegawaiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pegawai.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pegawaiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pegawai model
   */ 
  interface pegawaiFieldRefs {
    readonly id: FieldRef<"pegawai", 'Int'>
    readonly nama: FieldRef<"pegawai", 'String'>
    readonly nip: FieldRef<"pegawai", 'String'>
    readonly pangkat: FieldRef<"pegawai", 'String'>
    readonly jabatan: FieldRef<"pegawai", 'String'>
    readonly createdAt: FieldRef<"pegawai", 'DateTime'>
    readonly updatedAt: FieldRef<"pegawai", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * pegawai findUnique
   */
  export type pegawaiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * Filter, which pegawai to fetch.
     */
    where: pegawaiWhereUniqueInput
  }


  /**
   * pegawai findUniqueOrThrow
   */
  export type pegawaiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * Filter, which pegawai to fetch.
     */
    where: pegawaiWhereUniqueInput
  }


  /**
   * pegawai findFirst
   */
  export type pegawaiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * Filter, which pegawai to fetch.
     */
    where?: pegawaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pegawais to fetch.
     */
    orderBy?: pegawaiOrderByWithRelationInput | pegawaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pegawais.
     */
    cursor?: pegawaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pegawais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pegawais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pegawais.
     */
    distinct?: PegawaiScalarFieldEnum | PegawaiScalarFieldEnum[]
  }


  /**
   * pegawai findFirstOrThrow
   */
  export type pegawaiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * Filter, which pegawai to fetch.
     */
    where?: pegawaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pegawais to fetch.
     */
    orderBy?: pegawaiOrderByWithRelationInput | pegawaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pegawais.
     */
    cursor?: pegawaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pegawais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pegawais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pegawais.
     */
    distinct?: PegawaiScalarFieldEnum | PegawaiScalarFieldEnum[]
  }


  /**
   * pegawai findMany
   */
  export type pegawaiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * Filter, which pegawais to fetch.
     */
    where?: pegawaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pegawais to fetch.
     */
    orderBy?: pegawaiOrderByWithRelationInput | pegawaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pegawais.
     */
    cursor?: pegawaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pegawais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pegawais.
     */
    skip?: number
    distinct?: PegawaiScalarFieldEnum | PegawaiScalarFieldEnum[]
  }


  /**
   * pegawai create
   */
  export type pegawaiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * The data needed to create a pegawai.
     */
    data: XOR<pegawaiCreateInput, pegawaiUncheckedCreateInput>
  }


  /**
   * pegawai createMany
   */
  export type pegawaiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pegawais.
     */
    data: pegawaiCreateManyInput | pegawaiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pegawai update
   */
  export type pegawaiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * The data needed to update a pegawai.
     */
    data: XOR<pegawaiUpdateInput, pegawaiUncheckedUpdateInput>
    /**
     * Choose, which pegawai to update.
     */
    where: pegawaiWhereUniqueInput
  }


  /**
   * pegawai updateMany
   */
  export type pegawaiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pegawais.
     */
    data: XOR<pegawaiUpdateManyMutationInput, pegawaiUncheckedUpdateManyInput>
    /**
     * Filter which pegawais to update
     */
    where?: pegawaiWhereInput
  }


  /**
   * pegawai upsert
   */
  export type pegawaiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * The filter to search for the pegawai to update in case it exists.
     */
    where: pegawaiWhereUniqueInput
    /**
     * In case the pegawai found by the `where` argument doesn't exist, create a new pegawai with this data.
     */
    create: XOR<pegawaiCreateInput, pegawaiUncheckedCreateInput>
    /**
     * In case the pegawai was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pegawaiUpdateInput, pegawaiUncheckedUpdateInput>
  }


  /**
   * pegawai delete
   */
  export type pegawaiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
    /**
     * Filter which pegawai to delete.
     */
    where: pegawaiWhereUniqueInput
  }


  /**
   * pegawai deleteMany
   */
  export type pegawaiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pegawais to delete
     */
    where?: pegawaiWhereInput
  }


  /**
   * pegawai without action
   */
  export type pegawaiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pegawai
     */
    select?: pegawaiSelect<ExtArgs> | null
  }



  /**
   * Model cuacahariini
   */

  export type AggregateCuacahariini = {
    _count: CuacahariiniCountAggregateOutputType | null
    _avg: CuacahariiniAvgAggregateOutputType | null
    _sum: CuacahariiniSumAggregateOutputType | null
    _min: CuacahariiniMinAggregateOutputType | null
    _max: CuacahariiniMaxAggregateOutputType | null
  }

  export type CuacahariiniAvgAggregateOutputType = {
    id: number | null
  }

  export type CuacahariiniSumAggregateOutputType = {
    id: number | null
  }

  export type CuacahariiniMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuacahariiniMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuacahariiniCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CuacahariiniAvgAggregateInputType = {
    id?: true
  }

  export type CuacahariiniSumAggregateInputType = {
    id?: true
  }

  export type CuacahariiniMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuacahariiniMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuacahariiniCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CuacahariiniAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cuacahariini to aggregate.
     */
    where?: cuacahariiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacahariinis to fetch.
     */
    orderBy?: cuacahariiniOrderByWithRelationInput | cuacahariiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cuacahariiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacahariinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacahariinis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cuacahariinis
    **/
    _count?: true | CuacahariiniCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuacahariiniAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuacahariiniSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuacahariiniMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuacahariiniMaxAggregateInputType
  }

  export type GetCuacahariiniAggregateType<T extends CuacahariiniAggregateArgs> = {
        [P in keyof T & keyof AggregateCuacahariini]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuacahariini[P]>
      : GetScalarType<T[P], AggregateCuacahariini[P]>
  }




  export type cuacahariiniGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cuacahariiniWhereInput
    orderBy?: cuacahariiniOrderByWithAggregationInput | cuacahariiniOrderByWithAggregationInput[]
    by: CuacahariiniScalarFieldEnum[] | CuacahariiniScalarFieldEnum
    having?: cuacahariiniScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuacahariiniCountAggregateInputType | true
    _avg?: CuacahariiniAvgAggregateInputType
    _sum?: CuacahariiniSumAggregateInputType
    _min?: CuacahariiniMinAggregateInputType
    _max?: CuacahariiniMaxAggregateInputType
  }

  export type CuacahariiniGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: CuacahariiniCountAggregateOutputType | null
    _avg: CuacahariiniAvgAggregateOutputType | null
    _sum: CuacahariiniSumAggregateOutputType | null
    _min: CuacahariiniMinAggregateOutputType | null
    _max: CuacahariiniMaxAggregateOutputType | null
  }

  type GetCuacahariiniGroupByPayload<T extends cuacahariiniGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuacahariiniGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuacahariiniGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuacahariiniGroupByOutputType[P]>
            : GetScalarType<T[P], CuacahariiniGroupByOutputType[P]>
        }
      >
    >


  export type cuacahariiniSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cuacahariini"]>

  export type cuacahariiniSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $cuacahariiniPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cuacahariini"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cuacahariini"]>
    composites: {}
  }


  type cuacahariiniGetPayload<S extends boolean | null | undefined | cuacahariiniDefaultArgs> = $Result.GetResult<Prisma.$cuacahariiniPayload, S>

  type cuacahariiniCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cuacahariiniFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CuacahariiniCountAggregateInputType | true
    }

  export interface cuacahariiniDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cuacahariini'], meta: { name: 'cuacahariini' } }
    /**
     * Find zero or one Cuacahariini that matches the filter.
     * @param {cuacahariiniFindUniqueArgs} args - Arguments to find a Cuacahariini
     * @example
     * // Get one Cuacahariini
     * const cuacahariini = await prisma.cuacahariini.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cuacahariiniFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cuacahariiniFindUniqueArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cuacahariini that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cuacahariiniFindUniqueOrThrowArgs} args - Arguments to find a Cuacahariini
     * @example
     * // Get one Cuacahariini
     * const cuacahariini = await prisma.cuacahariini.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cuacahariiniFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacahariiniFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cuacahariini that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacahariiniFindFirstArgs} args - Arguments to find a Cuacahariini
     * @example
     * // Get one Cuacahariini
     * const cuacahariini = await prisma.cuacahariini.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cuacahariiniFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacahariiniFindFirstArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cuacahariini that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacahariiniFindFirstOrThrowArgs} args - Arguments to find a Cuacahariini
     * @example
     * // Get one Cuacahariini
     * const cuacahariini = await prisma.cuacahariini.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cuacahariiniFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacahariiniFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cuacahariinis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacahariiniFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuacahariinis
     * const cuacahariinis = await prisma.cuacahariini.findMany()
     * 
     * // Get first 10 Cuacahariinis
     * const cuacahariinis = await prisma.cuacahariini.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cuacahariiniWithIdOnly = await prisma.cuacahariini.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cuacahariiniFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacahariiniFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cuacahariini.
     * @param {cuacahariiniCreateArgs} args - Arguments to create a Cuacahariini.
     * @example
     * // Create one Cuacahariini
     * const Cuacahariini = await prisma.cuacahariini.create({
     *   data: {
     *     // ... data to create a Cuacahariini
     *   }
     * })
     * 
    **/
    create<T extends cuacahariiniCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cuacahariiniCreateArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cuacahariinis.
     *     @param {cuacahariiniCreateManyArgs} args - Arguments to create many Cuacahariinis.
     *     @example
     *     // Create many Cuacahariinis
     *     const cuacahariini = await prisma.cuacahariini.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cuacahariiniCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacahariiniCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cuacahariini.
     * @param {cuacahariiniDeleteArgs} args - Arguments to delete one Cuacahariini.
     * @example
     * // Delete one Cuacahariini
     * const Cuacahariini = await prisma.cuacahariini.delete({
     *   where: {
     *     // ... filter to delete one Cuacahariini
     *   }
     * })
     * 
    **/
    delete<T extends cuacahariiniDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cuacahariiniDeleteArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cuacahariini.
     * @param {cuacahariiniUpdateArgs} args - Arguments to update one Cuacahariini.
     * @example
     * // Update one Cuacahariini
     * const cuacahariini = await prisma.cuacahariini.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cuacahariiniUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cuacahariiniUpdateArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cuacahariinis.
     * @param {cuacahariiniDeleteManyArgs} args - Arguments to filter Cuacahariinis to delete.
     * @example
     * // Delete a few Cuacahariinis
     * const { count } = await prisma.cuacahariini.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cuacahariiniDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacahariiniDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuacahariinis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacahariiniUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuacahariinis
     * const cuacahariini = await prisma.cuacahariini.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cuacahariiniUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cuacahariiniUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cuacahariini.
     * @param {cuacahariiniUpsertArgs} args - Arguments to update or create a Cuacahariini.
     * @example
     * // Update or create a Cuacahariini
     * const cuacahariini = await prisma.cuacahariini.upsert({
     *   create: {
     *     // ... data to create a Cuacahariini
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuacahariini we want to update
     *   }
     * })
    **/
    upsert<T extends cuacahariiniUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cuacahariiniUpsertArgs<ExtArgs>>
    ): Prisma__cuacahariiniClient<$Result.GetResult<Prisma.$cuacahariiniPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cuacahariinis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacahariiniCountArgs} args - Arguments to filter Cuacahariinis to count.
     * @example
     * // Count the number of Cuacahariinis
     * const count = await prisma.cuacahariini.count({
     *   where: {
     *     // ... the filter for the Cuacahariinis we want to count
     *   }
     * })
    **/
    count<T extends cuacahariiniCountArgs>(
      args?: Subset<T, cuacahariiniCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuacahariiniCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuacahariini.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuacahariiniAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuacahariiniAggregateArgs>(args: Subset<T, CuacahariiniAggregateArgs>): Prisma.PrismaPromise<GetCuacahariiniAggregateType<T>>

    /**
     * Group by Cuacahariini.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacahariiniGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cuacahariiniGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cuacahariiniGroupByArgs['orderBy'] }
        : { orderBy?: cuacahariiniGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cuacahariiniGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuacahariiniGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cuacahariini model
   */
  readonly fields: cuacahariiniFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cuacahariini.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cuacahariiniClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cuacahariini model
   */ 
  interface cuacahariiniFieldRefs {
    readonly id: FieldRef<"cuacahariini", 'Int'>
    readonly name: FieldRef<"cuacahariini", 'DateTime'>
    readonly foto: FieldRef<"cuacahariini", 'String'>
    readonly url: FieldRef<"cuacahariini", 'String'>
    readonly createdAt: FieldRef<"cuacahariini", 'DateTime'>
    readonly updatedAt: FieldRef<"cuacahariini", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * cuacahariini findUnique
   */
  export type cuacahariiniFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * Filter, which cuacahariini to fetch.
     */
    where: cuacahariiniWhereUniqueInput
  }


  /**
   * cuacahariini findUniqueOrThrow
   */
  export type cuacahariiniFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * Filter, which cuacahariini to fetch.
     */
    where: cuacahariiniWhereUniqueInput
  }


  /**
   * cuacahariini findFirst
   */
  export type cuacahariiniFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * Filter, which cuacahariini to fetch.
     */
    where?: cuacahariiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacahariinis to fetch.
     */
    orderBy?: cuacahariiniOrderByWithRelationInput | cuacahariiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cuacahariinis.
     */
    cursor?: cuacahariiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacahariinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacahariinis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cuacahariinis.
     */
    distinct?: CuacahariiniScalarFieldEnum | CuacahariiniScalarFieldEnum[]
  }


  /**
   * cuacahariini findFirstOrThrow
   */
  export type cuacahariiniFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * Filter, which cuacahariini to fetch.
     */
    where?: cuacahariiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacahariinis to fetch.
     */
    orderBy?: cuacahariiniOrderByWithRelationInput | cuacahariiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cuacahariinis.
     */
    cursor?: cuacahariiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacahariinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacahariinis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cuacahariinis.
     */
    distinct?: CuacahariiniScalarFieldEnum | CuacahariiniScalarFieldEnum[]
  }


  /**
   * cuacahariini findMany
   */
  export type cuacahariiniFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * Filter, which cuacahariinis to fetch.
     */
    where?: cuacahariiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacahariinis to fetch.
     */
    orderBy?: cuacahariiniOrderByWithRelationInput | cuacahariiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cuacahariinis.
     */
    cursor?: cuacahariiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacahariinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacahariinis.
     */
    skip?: number
    distinct?: CuacahariiniScalarFieldEnum | CuacahariiniScalarFieldEnum[]
  }


  /**
   * cuacahariini create
   */
  export type cuacahariiniCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * The data needed to create a cuacahariini.
     */
    data: XOR<cuacahariiniCreateInput, cuacahariiniUncheckedCreateInput>
  }


  /**
   * cuacahariini createMany
   */
  export type cuacahariiniCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cuacahariinis.
     */
    data: cuacahariiniCreateManyInput | cuacahariiniCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cuacahariini update
   */
  export type cuacahariiniUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * The data needed to update a cuacahariini.
     */
    data: XOR<cuacahariiniUpdateInput, cuacahariiniUncheckedUpdateInput>
    /**
     * Choose, which cuacahariini to update.
     */
    where: cuacahariiniWhereUniqueInput
  }


  /**
   * cuacahariini updateMany
   */
  export type cuacahariiniUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cuacahariinis.
     */
    data: XOR<cuacahariiniUpdateManyMutationInput, cuacahariiniUncheckedUpdateManyInput>
    /**
     * Filter which cuacahariinis to update
     */
    where?: cuacahariiniWhereInput
  }


  /**
   * cuacahariini upsert
   */
  export type cuacahariiniUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * The filter to search for the cuacahariini to update in case it exists.
     */
    where: cuacahariiniWhereUniqueInput
    /**
     * In case the cuacahariini found by the `where` argument doesn't exist, create a new cuacahariini with this data.
     */
    create: XOR<cuacahariiniCreateInput, cuacahariiniUncheckedCreateInput>
    /**
     * In case the cuacahariini was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cuacahariiniUpdateInput, cuacahariiniUncheckedUpdateInput>
  }


  /**
   * cuacahariini delete
   */
  export type cuacahariiniDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
    /**
     * Filter which cuacahariini to delete.
     */
    where: cuacahariiniWhereUniqueInput
  }


  /**
   * cuacahariini deleteMany
   */
  export type cuacahariiniDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cuacahariinis to delete
     */
    where?: cuacahariiniWhereInput
  }


  /**
   * cuacahariini without action
   */
  export type cuacahariiniDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacahariini
     */
    select?: cuacahariiniSelect<ExtArgs> | null
  }



  /**
   * Model tourism
   */

  export type AggregateTourism = {
    _count: TourismCountAggregateOutputType | null
    _avg: TourismAvgAggregateOutputType | null
    _sum: TourismSumAggregateOutputType | null
    _min: TourismMinAggregateOutputType | null
    _max: TourismMaxAggregateOutputType | null
  }

  export type TourismAvgAggregateOutputType = {
    id: number | null
  }

  export type TourismSumAggregateOutputType = {
    id: number | null
  }

  export type TourismMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourismMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourismCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourismAvgAggregateInputType = {
    id?: true
  }

  export type TourismSumAggregateInputType = {
    id?: true
  }

  export type TourismMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourismMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourismCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourismAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tourism to aggregate.
     */
    where?: tourismWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourisms to fetch.
     */
    orderBy?: tourismOrderByWithRelationInput | tourismOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tourismWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourisms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourisms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tourisms
    **/
    _count?: true | TourismCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourismAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourismSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourismMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourismMaxAggregateInputType
  }

  export type GetTourismAggregateType<T extends TourismAggregateArgs> = {
        [P in keyof T & keyof AggregateTourism]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourism[P]>
      : GetScalarType<T[P], AggregateTourism[P]>
  }




  export type tourismGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tourismWhereInput
    orderBy?: tourismOrderByWithAggregationInput | tourismOrderByWithAggregationInput[]
    by: TourismScalarFieldEnum[] | TourismScalarFieldEnum
    having?: tourismScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourismCountAggregateInputType | true
    _avg?: TourismAvgAggregateInputType
    _sum?: TourismSumAggregateInputType
    _min?: TourismMinAggregateInputType
    _max?: TourismMaxAggregateInputType
  }

  export type TourismGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: TourismCountAggregateOutputType | null
    _avg: TourismAvgAggregateOutputType | null
    _sum: TourismSumAggregateOutputType | null
    _min: TourismMinAggregateOutputType | null
    _max: TourismMaxAggregateOutputType | null
  }

  type GetTourismGroupByPayload<T extends tourismGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourismGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourismGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourismGroupByOutputType[P]>
            : GetScalarType<T[P], TourismGroupByOutputType[P]>
        }
      >
    >


  export type tourismSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tourism"]>

  export type tourismSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $tourismPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tourism"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tourism"]>
    composites: {}
  }


  type tourismGetPayload<S extends boolean | null | undefined | tourismDefaultArgs> = $Result.GetResult<Prisma.$tourismPayload, S>

  type tourismCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tourismFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TourismCountAggregateInputType | true
    }

  export interface tourismDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tourism'], meta: { name: 'tourism' } }
    /**
     * Find zero or one Tourism that matches the filter.
     * @param {tourismFindUniqueArgs} args - Arguments to find a Tourism
     * @example
     * // Get one Tourism
     * const tourism = await prisma.tourism.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tourismFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tourismFindUniqueArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tourism that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tourismFindUniqueOrThrowArgs} args - Arguments to find a Tourism
     * @example
     * // Get one Tourism
     * const tourism = await prisma.tourism.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tourismFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tourismFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tourism that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourismFindFirstArgs} args - Arguments to find a Tourism
     * @example
     * // Get one Tourism
     * const tourism = await prisma.tourism.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tourismFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tourismFindFirstArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tourism that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourismFindFirstOrThrowArgs} args - Arguments to find a Tourism
     * @example
     * // Get one Tourism
     * const tourism = await prisma.tourism.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tourismFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tourismFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tourisms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourismFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tourisms
     * const tourisms = await prisma.tourism.findMany()
     * 
     * // Get first 10 Tourisms
     * const tourisms = await prisma.tourism.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourismWithIdOnly = await prisma.tourism.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tourismFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tourismFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tourism.
     * @param {tourismCreateArgs} args - Arguments to create a Tourism.
     * @example
     * // Create one Tourism
     * const Tourism = await prisma.tourism.create({
     *   data: {
     *     // ... data to create a Tourism
     *   }
     * })
     * 
    **/
    create<T extends tourismCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tourismCreateArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tourisms.
     *     @param {tourismCreateManyArgs} args - Arguments to create many Tourisms.
     *     @example
     *     // Create many Tourisms
     *     const tourism = await prisma.tourism.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tourismCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tourismCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tourism.
     * @param {tourismDeleteArgs} args - Arguments to delete one Tourism.
     * @example
     * // Delete one Tourism
     * const Tourism = await prisma.tourism.delete({
     *   where: {
     *     // ... filter to delete one Tourism
     *   }
     * })
     * 
    **/
    delete<T extends tourismDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tourismDeleteArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tourism.
     * @param {tourismUpdateArgs} args - Arguments to update one Tourism.
     * @example
     * // Update one Tourism
     * const tourism = await prisma.tourism.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tourismUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tourismUpdateArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tourisms.
     * @param {tourismDeleteManyArgs} args - Arguments to filter Tourisms to delete.
     * @example
     * // Delete a few Tourisms
     * const { count } = await prisma.tourism.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tourismDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tourismDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tourisms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourismUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tourisms
     * const tourism = await prisma.tourism.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tourismUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tourismUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tourism.
     * @param {tourismUpsertArgs} args - Arguments to update or create a Tourism.
     * @example
     * // Update or create a Tourism
     * const tourism = await prisma.tourism.upsert({
     *   create: {
     *     // ... data to create a Tourism
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tourism we want to update
     *   }
     * })
    **/
    upsert<T extends tourismUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tourismUpsertArgs<ExtArgs>>
    ): Prisma__tourismClient<$Result.GetResult<Prisma.$tourismPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tourisms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourismCountArgs} args - Arguments to filter Tourisms to count.
     * @example
     * // Count the number of Tourisms
     * const count = await prisma.tourism.count({
     *   where: {
     *     // ... the filter for the Tourisms we want to count
     *   }
     * })
    **/
    count<T extends tourismCountArgs>(
      args?: Subset<T, tourismCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourismCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tourism.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourismAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourismAggregateArgs>(args: Subset<T, TourismAggregateArgs>): Prisma.PrismaPromise<GetTourismAggregateType<T>>

    /**
     * Group by Tourism.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourismGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tourismGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tourismGroupByArgs['orderBy'] }
        : { orderBy?: tourismGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tourismGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourismGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tourism model
   */
  readonly fields: tourismFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tourism.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tourismClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tourism model
   */ 
  interface tourismFieldRefs {
    readonly id: FieldRef<"tourism", 'Int'>
    readonly name: FieldRef<"tourism", 'DateTime'>
    readonly foto: FieldRef<"tourism", 'String'>
    readonly url: FieldRef<"tourism", 'String'>
    readonly createdAt: FieldRef<"tourism", 'DateTime'>
    readonly updatedAt: FieldRef<"tourism", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * tourism findUnique
   */
  export type tourismFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * Filter, which tourism to fetch.
     */
    where: tourismWhereUniqueInput
  }


  /**
   * tourism findUniqueOrThrow
   */
  export type tourismFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * Filter, which tourism to fetch.
     */
    where: tourismWhereUniqueInput
  }


  /**
   * tourism findFirst
   */
  export type tourismFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * Filter, which tourism to fetch.
     */
    where?: tourismWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourisms to fetch.
     */
    orderBy?: tourismOrderByWithRelationInput | tourismOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tourisms.
     */
    cursor?: tourismWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourisms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourisms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tourisms.
     */
    distinct?: TourismScalarFieldEnum | TourismScalarFieldEnum[]
  }


  /**
   * tourism findFirstOrThrow
   */
  export type tourismFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * Filter, which tourism to fetch.
     */
    where?: tourismWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourisms to fetch.
     */
    orderBy?: tourismOrderByWithRelationInput | tourismOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tourisms.
     */
    cursor?: tourismWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourisms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourisms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tourisms.
     */
    distinct?: TourismScalarFieldEnum | TourismScalarFieldEnum[]
  }


  /**
   * tourism findMany
   */
  export type tourismFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * Filter, which tourisms to fetch.
     */
    where?: tourismWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourisms to fetch.
     */
    orderBy?: tourismOrderByWithRelationInput | tourismOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tourisms.
     */
    cursor?: tourismWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourisms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourisms.
     */
    skip?: number
    distinct?: TourismScalarFieldEnum | TourismScalarFieldEnum[]
  }


  /**
   * tourism create
   */
  export type tourismCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * The data needed to create a tourism.
     */
    data: XOR<tourismCreateInput, tourismUncheckedCreateInput>
  }


  /**
   * tourism createMany
   */
  export type tourismCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tourisms.
     */
    data: tourismCreateManyInput | tourismCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tourism update
   */
  export type tourismUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * The data needed to update a tourism.
     */
    data: XOR<tourismUpdateInput, tourismUncheckedUpdateInput>
    /**
     * Choose, which tourism to update.
     */
    where: tourismWhereUniqueInput
  }


  /**
   * tourism updateMany
   */
  export type tourismUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tourisms.
     */
    data: XOR<tourismUpdateManyMutationInput, tourismUncheckedUpdateManyInput>
    /**
     * Filter which tourisms to update
     */
    where?: tourismWhereInput
  }


  /**
   * tourism upsert
   */
  export type tourismUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * The filter to search for the tourism to update in case it exists.
     */
    where: tourismWhereUniqueInput
    /**
     * In case the tourism found by the `where` argument doesn't exist, create a new tourism with this data.
     */
    create: XOR<tourismCreateInput, tourismUncheckedCreateInput>
    /**
     * In case the tourism was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tourismUpdateInput, tourismUncheckedUpdateInput>
  }


  /**
   * tourism delete
   */
  export type tourismDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
    /**
     * Filter which tourism to delete.
     */
    where: tourismWhereUniqueInput
  }


  /**
   * tourism deleteMany
   */
  export type tourismDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tourisms to delete
     */
    where?: tourismWhereInput
  }


  /**
   * tourism without action
   */
  export type tourismDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourism
     */
    select?: tourismSelect<ExtArgs> | null
  }



  /**
   * Model analisiscurahhujan
   */

  export type AggregateAnalisiscurahhujan = {
    _count: AnalisiscurahhujanCountAggregateOutputType | null
    _avg: AnalisiscurahhujanAvgAggregateOutputType | null
    _sum: AnalisiscurahhujanSumAggregateOutputType | null
    _min: AnalisiscurahhujanMinAggregateOutputType | null
    _max: AnalisiscurahhujanMaxAggregateOutputType | null
  }

  export type AnalisiscurahhujanAvgAggregateOutputType = {
    id: number | null
  }

  export type AnalisiscurahhujanSumAggregateOutputType = {
    id: number | null
  }

  export type AnalisiscurahhujanMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalisiscurahhujanMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalisiscurahhujanCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalisiscurahhujanAvgAggregateInputType = {
    id?: true
  }

  export type AnalisiscurahhujanSumAggregateInputType = {
    id?: true
  }

  export type AnalisiscurahhujanMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalisiscurahhujanMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalisiscurahhujanCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalisiscurahhujanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analisiscurahhujan to aggregate.
     */
    where?: analisiscurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisiscurahhujans to fetch.
     */
    orderBy?: analisiscurahhujanOrderByWithRelationInput | analisiscurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: analisiscurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisiscurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisiscurahhujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned analisiscurahhujans
    **/
    _count?: true | AnalisiscurahhujanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalisiscurahhujanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalisiscurahhujanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalisiscurahhujanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalisiscurahhujanMaxAggregateInputType
  }

  export type GetAnalisiscurahhujanAggregateType<T extends AnalisiscurahhujanAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalisiscurahhujan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalisiscurahhujan[P]>
      : GetScalarType<T[P], AggregateAnalisiscurahhujan[P]>
  }




  export type analisiscurahhujanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analisiscurahhujanWhereInput
    orderBy?: analisiscurahhujanOrderByWithAggregationInput | analisiscurahhujanOrderByWithAggregationInput[]
    by: AnalisiscurahhujanScalarFieldEnum[] | AnalisiscurahhujanScalarFieldEnum
    having?: analisiscurahhujanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalisiscurahhujanCountAggregateInputType | true
    _avg?: AnalisiscurahhujanAvgAggregateInputType
    _sum?: AnalisiscurahhujanSumAggregateInputType
    _min?: AnalisiscurahhujanMinAggregateInputType
    _max?: AnalisiscurahhujanMaxAggregateInputType
  }

  export type AnalisiscurahhujanGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: AnalisiscurahhujanCountAggregateOutputType | null
    _avg: AnalisiscurahhujanAvgAggregateOutputType | null
    _sum: AnalisiscurahhujanSumAggregateOutputType | null
    _min: AnalisiscurahhujanMinAggregateOutputType | null
    _max: AnalisiscurahhujanMaxAggregateOutputType | null
  }

  type GetAnalisiscurahhujanGroupByPayload<T extends analisiscurahhujanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalisiscurahhujanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalisiscurahhujanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalisiscurahhujanGroupByOutputType[P]>
            : GetScalarType<T[P], AnalisiscurahhujanGroupByOutputType[P]>
        }
      >
    >


  export type analisiscurahhujanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analisiscurahhujan"]>

  export type analisiscurahhujanSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $analisiscurahhujanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "analisiscurahhujan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analisiscurahhujan"]>
    composites: {}
  }


  type analisiscurahhujanGetPayload<S extends boolean | null | undefined | analisiscurahhujanDefaultArgs> = $Result.GetResult<Prisma.$analisiscurahhujanPayload, S>

  type analisiscurahhujanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<analisiscurahhujanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AnalisiscurahhujanCountAggregateInputType | true
    }

  export interface analisiscurahhujanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['analisiscurahhujan'], meta: { name: 'analisiscurahhujan' } }
    /**
     * Find zero or one Analisiscurahhujan that matches the filter.
     * @param {analisiscurahhujanFindUniqueArgs} args - Arguments to find a Analisiscurahhujan
     * @example
     * // Get one Analisiscurahhujan
     * const analisiscurahhujan = await prisma.analisiscurahhujan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends analisiscurahhujanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, analisiscurahhujanFindUniqueArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Analisiscurahhujan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {analisiscurahhujanFindUniqueOrThrowArgs} args - Arguments to find a Analisiscurahhujan
     * @example
     * // Get one Analisiscurahhujan
     * const analisiscurahhujan = await prisma.analisiscurahhujan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends analisiscurahhujanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, analisiscurahhujanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Analisiscurahhujan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisiscurahhujanFindFirstArgs} args - Arguments to find a Analisiscurahhujan
     * @example
     * // Get one Analisiscurahhujan
     * const analisiscurahhujan = await prisma.analisiscurahhujan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends analisiscurahhujanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, analisiscurahhujanFindFirstArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Analisiscurahhujan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisiscurahhujanFindFirstOrThrowArgs} args - Arguments to find a Analisiscurahhujan
     * @example
     * // Get one Analisiscurahhujan
     * const analisiscurahhujan = await prisma.analisiscurahhujan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends analisiscurahhujanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, analisiscurahhujanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Analisiscurahhujans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisiscurahhujanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analisiscurahhujans
     * const analisiscurahhujans = await prisma.analisiscurahhujan.findMany()
     * 
     * // Get first 10 Analisiscurahhujans
     * const analisiscurahhujans = await prisma.analisiscurahhujan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analisiscurahhujanWithIdOnly = await prisma.analisiscurahhujan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends analisiscurahhujanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, analisiscurahhujanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Analisiscurahhujan.
     * @param {analisiscurahhujanCreateArgs} args - Arguments to create a Analisiscurahhujan.
     * @example
     * // Create one Analisiscurahhujan
     * const Analisiscurahhujan = await prisma.analisiscurahhujan.create({
     *   data: {
     *     // ... data to create a Analisiscurahhujan
     *   }
     * })
     * 
    **/
    create<T extends analisiscurahhujanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, analisiscurahhujanCreateArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Analisiscurahhujans.
     *     @param {analisiscurahhujanCreateManyArgs} args - Arguments to create many Analisiscurahhujans.
     *     @example
     *     // Create many Analisiscurahhujans
     *     const analisiscurahhujan = await prisma.analisiscurahhujan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends analisiscurahhujanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, analisiscurahhujanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Analisiscurahhujan.
     * @param {analisiscurahhujanDeleteArgs} args - Arguments to delete one Analisiscurahhujan.
     * @example
     * // Delete one Analisiscurahhujan
     * const Analisiscurahhujan = await prisma.analisiscurahhujan.delete({
     *   where: {
     *     // ... filter to delete one Analisiscurahhujan
     *   }
     * })
     * 
    **/
    delete<T extends analisiscurahhujanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, analisiscurahhujanDeleteArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Analisiscurahhujan.
     * @param {analisiscurahhujanUpdateArgs} args - Arguments to update one Analisiscurahhujan.
     * @example
     * // Update one Analisiscurahhujan
     * const analisiscurahhujan = await prisma.analisiscurahhujan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends analisiscurahhujanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, analisiscurahhujanUpdateArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Analisiscurahhujans.
     * @param {analisiscurahhujanDeleteManyArgs} args - Arguments to filter Analisiscurahhujans to delete.
     * @example
     * // Delete a few Analisiscurahhujans
     * const { count } = await prisma.analisiscurahhujan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends analisiscurahhujanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, analisiscurahhujanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analisiscurahhujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisiscurahhujanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analisiscurahhujans
     * const analisiscurahhujan = await prisma.analisiscurahhujan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends analisiscurahhujanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, analisiscurahhujanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analisiscurahhujan.
     * @param {analisiscurahhujanUpsertArgs} args - Arguments to update or create a Analisiscurahhujan.
     * @example
     * // Update or create a Analisiscurahhujan
     * const analisiscurahhujan = await prisma.analisiscurahhujan.upsert({
     *   create: {
     *     // ... data to create a Analisiscurahhujan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analisiscurahhujan we want to update
     *   }
     * })
    **/
    upsert<T extends analisiscurahhujanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, analisiscurahhujanUpsertArgs<ExtArgs>>
    ): Prisma__analisiscurahhujanClient<$Result.GetResult<Prisma.$analisiscurahhujanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Analisiscurahhujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisiscurahhujanCountArgs} args - Arguments to filter Analisiscurahhujans to count.
     * @example
     * // Count the number of Analisiscurahhujans
     * const count = await prisma.analisiscurahhujan.count({
     *   where: {
     *     // ... the filter for the Analisiscurahhujans we want to count
     *   }
     * })
    **/
    count<T extends analisiscurahhujanCountArgs>(
      args?: Subset<T, analisiscurahhujanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalisiscurahhujanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analisiscurahhujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalisiscurahhujanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalisiscurahhujanAggregateArgs>(args: Subset<T, AnalisiscurahhujanAggregateArgs>): Prisma.PrismaPromise<GetAnalisiscurahhujanAggregateType<T>>

    /**
     * Group by Analisiscurahhujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisiscurahhujanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends analisiscurahhujanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: analisiscurahhujanGroupByArgs['orderBy'] }
        : { orderBy?: analisiscurahhujanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, analisiscurahhujanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalisiscurahhujanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the analisiscurahhujan model
   */
  readonly fields: analisiscurahhujanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for analisiscurahhujan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__analisiscurahhujanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the analisiscurahhujan model
   */ 
  interface analisiscurahhujanFieldRefs {
    readonly id: FieldRef<"analisiscurahhujan", 'Int'>
    readonly name: FieldRef<"analisiscurahhujan", 'DateTime'>
    readonly foto: FieldRef<"analisiscurahhujan", 'String'>
    readonly url: FieldRef<"analisiscurahhujan", 'String'>
    readonly createdAt: FieldRef<"analisiscurahhujan", 'DateTime'>
    readonly updatedAt: FieldRef<"analisiscurahhujan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * analisiscurahhujan findUnique
   */
  export type analisiscurahhujanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which analisiscurahhujan to fetch.
     */
    where: analisiscurahhujanWhereUniqueInput
  }


  /**
   * analisiscurahhujan findUniqueOrThrow
   */
  export type analisiscurahhujanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which analisiscurahhujan to fetch.
     */
    where: analisiscurahhujanWhereUniqueInput
  }


  /**
   * analisiscurahhujan findFirst
   */
  export type analisiscurahhujanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which analisiscurahhujan to fetch.
     */
    where?: analisiscurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisiscurahhujans to fetch.
     */
    orderBy?: analisiscurahhujanOrderByWithRelationInput | analisiscurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analisiscurahhujans.
     */
    cursor?: analisiscurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisiscurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisiscurahhujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analisiscurahhujans.
     */
    distinct?: AnalisiscurahhujanScalarFieldEnum | AnalisiscurahhujanScalarFieldEnum[]
  }


  /**
   * analisiscurahhujan findFirstOrThrow
   */
  export type analisiscurahhujanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which analisiscurahhujan to fetch.
     */
    where?: analisiscurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisiscurahhujans to fetch.
     */
    orderBy?: analisiscurahhujanOrderByWithRelationInput | analisiscurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analisiscurahhujans.
     */
    cursor?: analisiscurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisiscurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisiscurahhujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analisiscurahhujans.
     */
    distinct?: AnalisiscurahhujanScalarFieldEnum | AnalisiscurahhujanScalarFieldEnum[]
  }


  /**
   * analisiscurahhujan findMany
   */
  export type analisiscurahhujanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which analisiscurahhujans to fetch.
     */
    where?: analisiscurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisiscurahhujans to fetch.
     */
    orderBy?: analisiscurahhujanOrderByWithRelationInput | analisiscurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing analisiscurahhujans.
     */
    cursor?: analisiscurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisiscurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisiscurahhujans.
     */
    skip?: number
    distinct?: AnalisiscurahhujanScalarFieldEnum | AnalisiscurahhujanScalarFieldEnum[]
  }


  /**
   * analisiscurahhujan create
   */
  export type analisiscurahhujanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * The data needed to create a analisiscurahhujan.
     */
    data: XOR<analisiscurahhujanCreateInput, analisiscurahhujanUncheckedCreateInput>
  }


  /**
   * analisiscurahhujan createMany
   */
  export type analisiscurahhujanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many analisiscurahhujans.
     */
    data: analisiscurahhujanCreateManyInput | analisiscurahhujanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * analisiscurahhujan update
   */
  export type analisiscurahhujanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * The data needed to update a analisiscurahhujan.
     */
    data: XOR<analisiscurahhujanUpdateInput, analisiscurahhujanUncheckedUpdateInput>
    /**
     * Choose, which analisiscurahhujan to update.
     */
    where: analisiscurahhujanWhereUniqueInput
  }


  /**
   * analisiscurahhujan updateMany
   */
  export type analisiscurahhujanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update analisiscurahhujans.
     */
    data: XOR<analisiscurahhujanUpdateManyMutationInput, analisiscurahhujanUncheckedUpdateManyInput>
    /**
     * Filter which analisiscurahhujans to update
     */
    where?: analisiscurahhujanWhereInput
  }


  /**
   * analisiscurahhujan upsert
   */
  export type analisiscurahhujanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * The filter to search for the analisiscurahhujan to update in case it exists.
     */
    where: analisiscurahhujanWhereUniqueInput
    /**
     * In case the analisiscurahhujan found by the `where` argument doesn't exist, create a new analisiscurahhujan with this data.
     */
    create: XOR<analisiscurahhujanCreateInput, analisiscurahhujanUncheckedCreateInput>
    /**
     * In case the analisiscurahhujan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<analisiscurahhujanUpdateInput, analisiscurahhujanUncheckedUpdateInput>
  }


  /**
   * analisiscurahhujan delete
   */
  export type analisiscurahhujanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
    /**
     * Filter which analisiscurahhujan to delete.
     */
    where: analisiscurahhujanWhereUniqueInput
  }


  /**
   * analisiscurahhujan deleteMany
   */
  export type analisiscurahhujanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analisiscurahhujans to delete
     */
    where?: analisiscurahhujanWhereInput
  }


  /**
   * analisiscurahhujan without action
   */
  export type analisiscurahhujanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisiscurahhujan
     */
    select?: analisiscurahhujanSelect<ExtArgs> | null
  }



  /**
   * Model analisissifathujan
   */

  export type AggregateAnalisissifathujan = {
    _count: AnalisissifathujanCountAggregateOutputType | null
    _avg: AnalisissifathujanAvgAggregateOutputType | null
    _sum: AnalisissifathujanSumAggregateOutputType | null
    _min: AnalisissifathujanMinAggregateOutputType | null
    _max: AnalisissifathujanMaxAggregateOutputType | null
  }

  export type AnalisissifathujanAvgAggregateOutputType = {
    id: number | null
  }

  export type AnalisissifathujanSumAggregateOutputType = {
    id: number | null
  }

  export type AnalisissifathujanMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalisissifathujanMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalisissifathujanCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalisissifathujanAvgAggregateInputType = {
    id?: true
  }

  export type AnalisissifathujanSumAggregateInputType = {
    id?: true
  }

  export type AnalisissifathujanMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalisissifathujanMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalisissifathujanCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalisissifathujanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analisissifathujan to aggregate.
     */
    where?: analisissifathujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisissifathujans to fetch.
     */
    orderBy?: analisissifathujanOrderByWithRelationInput | analisissifathujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: analisissifathujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisissifathujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisissifathujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned analisissifathujans
    **/
    _count?: true | AnalisissifathujanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalisissifathujanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalisissifathujanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalisissifathujanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalisissifathujanMaxAggregateInputType
  }

  export type GetAnalisissifathujanAggregateType<T extends AnalisissifathujanAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalisissifathujan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalisissifathujan[P]>
      : GetScalarType<T[P], AggregateAnalisissifathujan[P]>
  }




  export type analisissifathujanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analisissifathujanWhereInput
    orderBy?: analisissifathujanOrderByWithAggregationInput | analisissifathujanOrderByWithAggregationInput[]
    by: AnalisissifathujanScalarFieldEnum[] | AnalisissifathujanScalarFieldEnum
    having?: analisissifathujanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalisissifathujanCountAggregateInputType | true
    _avg?: AnalisissifathujanAvgAggregateInputType
    _sum?: AnalisissifathujanSumAggregateInputType
    _min?: AnalisissifathujanMinAggregateInputType
    _max?: AnalisissifathujanMaxAggregateInputType
  }

  export type AnalisissifathujanGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: AnalisissifathujanCountAggregateOutputType | null
    _avg: AnalisissifathujanAvgAggregateOutputType | null
    _sum: AnalisissifathujanSumAggregateOutputType | null
    _min: AnalisissifathujanMinAggregateOutputType | null
    _max: AnalisissifathujanMaxAggregateOutputType | null
  }

  type GetAnalisissifathujanGroupByPayload<T extends analisissifathujanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalisissifathujanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalisissifathujanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalisissifathujanGroupByOutputType[P]>
            : GetScalarType<T[P], AnalisissifathujanGroupByOutputType[P]>
        }
      >
    >


  export type analisissifathujanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analisissifathujan"]>

  export type analisissifathujanSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $analisissifathujanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "analisissifathujan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analisissifathujan"]>
    composites: {}
  }


  type analisissifathujanGetPayload<S extends boolean | null | undefined | analisissifathujanDefaultArgs> = $Result.GetResult<Prisma.$analisissifathujanPayload, S>

  type analisissifathujanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<analisissifathujanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AnalisissifathujanCountAggregateInputType | true
    }

  export interface analisissifathujanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['analisissifathujan'], meta: { name: 'analisissifathujan' } }
    /**
     * Find zero or one Analisissifathujan that matches the filter.
     * @param {analisissifathujanFindUniqueArgs} args - Arguments to find a Analisissifathujan
     * @example
     * // Get one Analisissifathujan
     * const analisissifathujan = await prisma.analisissifathujan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends analisissifathujanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, analisissifathujanFindUniqueArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Analisissifathujan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {analisissifathujanFindUniqueOrThrowArgs} args - Arguments to find a Analisissifathujan
     * @example
     * // Get one Analisissifathujan
     * const analisissifathujan = await prisma.analisissifathujan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends analisissifathujanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, analisissifathujanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Analisissifathujan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisissifathujanFindFirstArgs} args - Arguments to find a Analisissifathujan
     * @example
     * // Get one Analisissifathujan
     * const analisissifathujan = await prisma.analisissifathujan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends analisissifathujanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, analisissifathujanFindFirstArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Analisissifathujan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisissifathujanFindFirstOrThrowArgs} args - Arguments to find a Analisissifathujan
     * @example
     * // Get one Analisissifathujan
     * const analisissifathujan = await prisma.analisissifathujan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends analisissifathujanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, analisissifathujanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Analisissifathujans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisissifathujanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analisissifathujans
     * const analisissifathujans = await prisma.analisissifathujan.findMany()
     * 
     * // Get first 10 Analisissifathujans
     * const analisissifathujans = await prisma.analisissifathujan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analisissifathujanWithIdOnly = await prisma.analisissifathujan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends analisissifathujanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, analisissifathujanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Analisissifathujan.
     * @param {analisissifathujanCreateArgs} args - Arguments to create a Analisissifathujan.
     * @example
     * // Create one Analisissifathujan
     * const Analisissifathujan = await prisma.analisissifathujan.create({
     *   data: {
     *     // ... data to create a Analisissifathujan
     *   }
     * })
     * 
    **/
    create<T extends analisissifathujanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, analisissifathujanCreateArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Analisissifathujans.
     *     @param {analisissifathujanCreateManyArgs} args - Arguments to create many Analisissifathujans.
     *     @example
     *     // Create many Analisissifathujans
     *     const analisissifathujan = await prisma.analisissifathujan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends analisissifathujanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, analisissifathujanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Analisissifathujan.
     * @param {analisissifathujanDeleteArgs} args - Arguments to delete one Analisissifathujan.
     * @example
     * // Delete one Analisissifathujan
     * const Analisissifathujan = await prisma.analisissifathujan.delete({
     *   where: {
     *     // ... filter to delete one Analisissifathujan
     *   }
     * })
     * 
    **/
    delete<T extends analisissifathujanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, analisissifathujanDeleteArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Analisissifathujan.
     * @param {analisissifathujanUpdateArgs} args - Arguments to update one Analisissifathujan.
     * @example
     * // Update one Analisissifathujan
     * const analisissifathujan = await prisma.analisissifathujan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends analisissifathujanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, analisissifathujanUpdateArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Analisissifathujans.
     * @param {analisissifathujanDeleteManyArgs} args - Arguments to filter Analisissifathujans to delete.
     * @example
     * // Delete a few Analisissifathujans
     * const { count } = await prisma.analisissifathujan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends analisissifathujanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, analisissifathujanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analisissifathujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisissifathujanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analisissifathujans
     * const analisissifathujan = await prisma.analisissifathujan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends analisissifathujanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, analisissifathujanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analisissifathujan.
     * @param {analisissifathujanUpsertArgs} args - Arguments to update or create a Analisissifathujan.
     * @example
     * // Update or create a Analisissifathujan
     * const analisissifathujan = await prisma.analisissifathujan.upsert({
     *   create: {
     *     // ... data to create a Analisissifathujan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analisissifathujan we want to update
     *   }
     * })
    **/
    upsert<T extends analisissifathujanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, analisissifathujanUpsertArgs<ExtArgs>>
    ): Prisma__analisissifathujanClient<$Result.GetResult<Prisma.$analisissifathujanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Analisissifathujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisissifathujanCountArgs} args - Arguments to filter Analisissifathujans to count.
     * @example
     * // Count the number of Analisissifathujans
     * const count = await prisma.analisissifathujan.count({
     *   where: {
     *     // ... the filter for the Analisissifathujans we want to count
     *   }
     * })
    **/
    count<T extends analisissifathujanCountArgs>(
      args?: Subset<T, analisissifathujanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalisissifathujanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analisissifathujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalisissifathujanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalisissifathujanAggregateArgs>(args: Subset<T, AnalisissifathujanAggregateArgs>): Prisma.PrismaPromise<GetAnalisissifathujanAggregateType<T>>

    /**
     * Group by Analisissifathujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisissifathujanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends analisissifathujanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: analisissifathujanGroupByArgs['orderBy'] }
        : { orderBy?: analisissifathujanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, analisissifathujanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalisissifathujanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the analisissifathujan model
   */
  readonly fields: analisissifathujanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for analisissifathujan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__analisissifathujanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the analisissifathujan model
   */ 
  interface analisissifathujanFieldRefs {
    readonly id: FieldRef<"analisissifathujan", 'Int'>
    readonly name: FieldRef<"analisissifathujan", 'DateTime'>
    readonly foto: FieldRef<"analisissifathujan", 'String'>
    readonly url: FieldRef<"analisissifathujan", 'String'>
    readonly createdAt: FieldRef<"analisissifathujan", 'DateTime'>
    readonly updatedAt: FieldRef<"analisissifathujan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * analisissifathujan findUnique
   */
  export type analisissifathujanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * Filter, which analisissifathujan to fetch.
     */
    where: analisissifathujanWhereUniqueInput
  }


  /**
   * analisissifathujan findUniqueOrThrow
   */
  export type analisissifathujanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * Filter, which analisissifathujan to fetch.
     */
    where: analisissifathujanWhereUniqueInput
  }


  /**
   * analisissifathujan findFirst
   */
  export type analisissifathujanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * Filter, which analisissifathujan to fetch.
     */
    where?: analisissifathujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisissifathujans to fetch.
     */
    orderBy?: analisissifathujanOrderByWithRelationInput | analisissifathujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analisissifathujans.
     */
    cursor?: analisissifathujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisissifathujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisissifathujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analisissifathujans.
     */
    distinct?: AnalisissifathujanScalarFieldEnum | AnalisissifathujanScalarFieldEnum[]
  }


  /**
   * analisissifathujan findFirstOrThrow
   */
  export type analisissifathujanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * Filter, which analisissifathujan to fetch.
     */
    where?: analisissifathujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisissifathujans to fetch.
     */
    orderBy?: analisissifathujanOrderByWithRelationInput | analisissifathujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analisissifathujans.
     */
    cursor?: analisissifathujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisissifathujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisissifathujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analisissifathujans.
     */
    distinct?: AnalisissifathujanScalarFieldEnum | AnalisissifathujanScalarFieldEnum[]
  }


  /**
   * analisissifathujan findMany
   */
  export type analisissifathujanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * Filter, which analisissifathujans to fetch.
     */
    where?: analisissifathujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisissifathujans to fetch.
     */
    orderBy?: analisissifathujanOrderByWithRelationInput | analisissifathujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing analisissifathujans.
     */
    cursor?: analisissifathujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisissifathujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisissifathujans.
     */
    skip?: number
    distinct?: AnalisissifathujanScalarFieldEnum | AnalisissifathujanScalarFieldEnum[]
  }


  /**
   * analisissifathujan create
   */
  export type analisissifathujanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * The data needed to create a analisissifathujan.
     */
    data: XOR<analisissifathujanCreateInput, analisissifathujanUncheckedCreateInput>
  }


  /**
   * analisissifathujan createMany
   */
  export type analisissifathujanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many analisissifathujans.
     */
    data: analisissifathujanCreateManyInput | analisissifathujanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * analisissifathujan update
   */
  export type analisissifathujanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * The data needed to update a analisissifathujan.
     */
    data: XOR<analisissifathujanUpdateInput, analisissifathujanUncheckedUpdateInput>
    /**
     * Choose, which analisissifathujan to update.
     */
    where: analisissifathujanWhereUniqueInput
  }


  /**
   * analisissifathujan updateMany
   */
  export type analisissifathujanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update analisissifathujans.
     */
    data: XOR<analisissifathujanUpdateManyMutationInput, analisissifathujanUncheckedUpdateManyInput>
    /**
     * Filter which analisissifathujans to update
     */
    where?: analisissifathujanWhereInput
  }


  /**
   * analisissifathujan upsert
   */
  export type analisissifathujanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * The filter to search for the analisissifathujan to update in case it exists.
     */
    where: analisissifathujanWhereUniqueInput
    /**
     * In case the analisissifathujan found by the `where` argument doesn't exist, create a new analisissifathujan with this data.
     */
    create: XOR<analisissifathujanCreateInput, analisissifathujanUncheckedCreateInput>
    /**
     * In case the analisissifathujan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<analisissifathujanUpdateInput, analisissifathujanUncheckedUpdateInput>
  }


  /**
   * analisissifathujan delete
   */
  export type analisissifathujanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
    /**
     * Filter which analisissifathujan to delete.
     */
    where: analisissifathujanWhereUniqueInput
  }


  /**
   * analisissifathujan deleteMany
   */
  export type analisissifathujanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analisissifathujans to delete
     */
    where?: analisissifathujanWhereInput
  }


  /**
   * analisissifathujan without action
   */
  export type analisissifathujanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisissifathujan
     */
    select?: analisissifathujanSelect<ExtArgs> | null
  }



  /**
   * Model prakiraancurahhujan
   */

  export type AggregatePrakiraancurahhujan = {
    _count: PrakiraancurahhujanCountAggregateOutputType | null
    _avg: PrakiraancurahhujanAvgAggregateOutputType | null
    _sum: PrakiraancurahhujanSumAggregateOutputType | null
    _min: PrakiraancurahhujanMinAggregateOutputType | null
    _max: PrakiraancurahhujanMaxAggregateOutputType | null
  }

  export type PrakiraancurahhujanAvgAggregateOutputType = {
    id: number | null
  }

  export type PrakiraancurahhujanSumAggregateOutputType = {
    id: number | null
  }

  export type PrakiraancurahhujanMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrakiraancurahhujanMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrakiraancurahhujanCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrakiraancurahhujanAvgAggregateInputType = {
    id?: true
  }

  export type PrakiraancurahhujanSumAggregateInputType = {
    id?: true
  }

  export type PrakiraancurahhujanMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrakiraancurahhujanMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrakiraancurahhujanCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrakiraancurahhujanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prakiraancurahhujan to aggregate.
     */
    where?: prakiraancurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prakiraancurahhujans to fetch.
     */
    orderBy?: prakiraancurahhujanOrderByWithRelationInput | prakiraancurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prakiraancurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prakiraancurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prakiraancurahhujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prakiraancurahhujans
    **/
    _count?: true | PrakiraancurahhujanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrakiraancurahhujanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrakiraancurahhujanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrakiraancurahhujanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrakiraancurahhujanMaxAggregateInputType
  }

  export type GetPrakiraancurahhujanAggregateType<T extends PrakiraancurahhujanAggregateArgs> = {
        [P in keyof T & keyof AggregatePrakiraancurahhujan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrakiraancurahhujan[P]>
      : GetScalarType<T[P], AggregatePrakiraancurahhujan[P]>
  }




  export type prakiraancurahhujanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prakiraancurahhujanWhereInput
    orderBy?: prakiraancurahhujanOrderByWithAggregationInput | prakiraancurahhujanOrderByWithAggregationInput[]
    by: PrakiraancurahhujanScalarFieldEnum[] | PrakiraancurahhujanScalarFieldEnum
    having?: prakiraancurahhujanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrakiraancurahhujanCountAggregateInputType | true
    _avg?: PrakiraancurahhujanAvgAggregateInputType
    _sum?: PrakiraancurahhujanSumAggregateInputType
    _min?: PrakiraancurahhujanMinAggregateInputType
    _max?: PrakiraancurahhujanMaxAggregateInputType
  }

  export type PrakiraancurahhujanGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: PrakiraancurahhujanCountAggregateOutputType | null
    _avg: PrakiraancurahhujanAvgAggregateOutputType | null
    _sum: PrakiraancurahhujanSumAggregateOutputType | null
    _min: PrakiraancurahhujanMinAggregateOutputType | null
    _max: PrakiraancurahhujanMaxAggregateOutputType | null
  }

  type GetPrakiraancurahhujanGroupByPayload<T extends prakiraancurahhujanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrakiraancurahhujanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrakiraancurahhujanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrakiraancurahhujanGroupByOutputType[P]>
            : GetScalarType<T[P], PrakiraancurahhujanGroupByOutputType[P]>
        }
      >
    >


  export type prakiraancurahhujanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["prakiraancurahhujan"]>

  export type prakiraancurahhujanSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $prakiraancurahhujanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prakiraancurahhujan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prakiraancurahhujan"]>
    composites: {}
  }


  type prakiraancurahhujanGetPayload<S extends boolean | null | undefined | prakiraancurahhujanDefaultArgs> = $Result.GetResult<Prisma.$prakiraancurahhujanPayload, S>

  type prakiraancurahhujanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prakiraancurahhujanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PrakiraancurahhujanCountAggregateInputType | true
    }

  export interface prakiraancurahhujanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prakiraancurahhujan'], meta: { name: 'prakiraancurahhujan' } }
    /**
     * Find zero or one Prakiraancurahhujan that matches the filter.
     * @param {prakiraancurahhujanFindUniqueArgs} args - Arguments to find a Prakiraancurahhujan
     * @example
     * // Get one Prakiraancurahhujan
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prakiraancurahhujanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, prakiraancurahhujanFindUniqueArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Prakiraancurahhujan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {prakiraancurahhujanFindUniqueOrThrowArgs} args - Arguments to find a Prakiraancurahhujan
     * @example
     * // Get one Prakiraancurahhujan
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends prakiraancurahhujanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prakiraancurahhujanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Prakiraancurahhujan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prakiraancurahhujanFindFirstArgs} args - Arguments to find a Prakiraancurahhujan
     * @example
     * // Get one Prakiraancurahhujan
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prakiraancurahhujanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, prakiraancurahhujanFindFirstArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Prakiraancurahhujan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prakiraancurahhujanFindFirstOrThrowArgs} args - Arguments to find a Prakiraancurahhujan
     * @example
     * // Get one Prakiraancurahhujan
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends prakiraancurahhujanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prakiraancurahhujanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Prakiraancurahhujans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prakiraancurahhujanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prakiraancurahhujans
     * const prakiraancurahhujans = await prisma.prakiraancurahhujan.findMany()
     * 
     * // Get first 10 Prakiraancurahhujans
     * const prakiraancurahhujans = await prisma.prakiraancurahhujan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prakiraancurahhujanWithIdOnly = await prisma.prakiraancurahhujan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends prakiraancurahhujanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prakiraancurahhujanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Prakiraancurahhujan.
     * @param {prakiraancurahhujanCreateArgs} args - Arguments to create a Prakiraancurahhujan.
     * @example
     * // Create one Prakiraancurahhujan
     * const Prakiraancurahhujan = await prisma.prakiraancurahhujan.create({
     *   data: {
     *     // ... data to create a Prakiraancurahhujan
     *   }
     * })
     * 
    **/
    create<T extends prakiraancurahhujanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, prakiraancurahhujanCreateArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Prakiraancurahhujans.
     *     @param {prakiraancurahhujanCreateManyArgs} args - Arguments to create many Prakiraancurahhujans.
     *     @example
     *     // Create many Prakiraancurahhujans
     *     const prakiraancurahhujan = await prisma.prakiraancurahhujan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends prakiraancurahhujanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prakiraancurahhujanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prakiraancurahhujan.
     * @param {prakiraancurahhujanDeleteArgs} args - Arguments to delete one Prakiraancurahhujan.
     * @example
     * // Delete one Prakiraancurahhujan
     * const Prakiraancurahhujan = await prisma.prakiraancurahhujan.delete({
     *   where: {
     *     // ... filter to delete one Prakiraancurahhujan
     *   }
     * })
     * 
    **/
    delete<T extends prakiraancurahhujanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, prakiraancurahhujanDeleteArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Prakiraancurahhujan.
     * @param {prakiraancurahhujanUpdateArgs} args - Arguments to update one Prakiraancurahhujan.
     * @example
     * // Update one Prakiraancurahhujan
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prakiraancurahhujanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, prakiraancurahhujanUpdateArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Prakiraancurahhujans.
     * @param {prakiraancurahhujanDeleteManyArgs} args - Arguments to filter Prakiraancurahhujans to delete.
     * @example
     * // Delete a few Prakiraancurahhujans
     * const { count } = await prisma.prakiraancurahhujan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prakiraancurahhujanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prakiraancurahhujanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prakiraancurahhujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prakiraancurahhujanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prakiraancurahhujans
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prakiraancurahhujanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, prakiraancurahhujanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prakiraancurahhujan.
     * @param {prakiraancurahhujanUpsertArgs} args - Arguments to update or create a Prakiraancurahhujan.
     * @example
     * // Update or create a Prakiraancurahhujan
     * const prakiraancurahhujan = await prisma.prakiraancurahhujan.upsert({
     *   create: {
     *     // ... data to create a Prakiraancurahhujan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prakiraancurahhujan we want to update
     *   }
     * })
    **/
    upsert<T extends prakiraancurahhujanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, prakiraancurahhujanUpsertArgs<ExtArgs>>
    ): Prisma__prakiraancurahhujanClient<$Result.GetResult<Prisma.$prakiraancurahhujanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Prakiraancurahhujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prakiraancurahhujanCountArgs} args - Arguments to filter Prakiraancurahhujans to count.
     * @example
     * // Count the number of Prakiraancurahhujans
     * const count = await prisma.prakiraancurahhujan.count({
     *   where: {
     *     // ... the filter for the Prakiraancurahhujans we want to count
     *   }
     * })
    **/
    count<T extends prakiraancurahhujanCountArgs>(
      args?: Subset<T, prakiraancurahhujanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrakiraancurahhujanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prakiraancurahhujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrakiraancurahhujanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrakiraancurahhujanAggregateArgs>(args: Subset<T, PrakiraancurahhujanAggregateArgs>): Prisma.PrismaPromise<GetPrakiraancurahhujanAggregateType<T>>

    /**
     * Group by Prakiraancurahhujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prakiraancurahhujanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prakiraancurahhujanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prakiraancurahhujanGroupByArgs['orderBy'] }
        : { orderBy?: prakiraancurahhujanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prakiraancurahhujanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrakiraancurahhujanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prakiraancurahhujan model
   */
  readonly fields: prakiraancurahhujanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prakiraancurahhujan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prakiraancurahhujanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the prakiraancurahhujan model
   */ 
  interface prakiraancurahhujanFieldRefs {
    readonly id: FieldRef<"prakiraancurahhujan", 'Int'>
    readonly name: FieldRef<"prakiraancurahhujan", 'DateTime'>
    readonly foto: FieldRef<"prakiraancurahhujan", 'String'>
    readonly url: FieldRef<"prakiraancurahhujan", 'String'>
    readonly createdAt: FieldRef<"prakiraancurahhujan", 'DateTime'>
    readonly updatedAt: FieldRef<"prakiraancurahhujan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * prakiraancurahhujan findUnique
   */
  export type prakiraancurahhujanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which prakiraancurahhujan to fetch.
     */
    where: prakiraancurahhujanWhereUniqueInput
  }


  /**
   * prakiraancurahhujan findUniqueOrThrow
   */
  export type prakiraancurahhujanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which prakiraancurahhujan to fetch.
     */
    where: prakiraancurahhujanWhereUniqueInput
  }


  /**
   * prakiraancurahhujan findFirst
   */
  export type prakiraancurahhujanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which prakiraancurahhujan to fetch.
     */
    where?: prakiraancurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prakiraancurahhujans to fetch.
     */
    orderBy?: prakiraancurahhujanOrderByWithRelationInput | prakiraancurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prakiraancurahhujans.
     */
    cursor?: prakiraancurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prakiraancurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prakiraancurahhujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prakiraancurahhujans.
     */
    distinct?: PrakiraancurahhujanScalarFieldEnum | PrakiraancurahhujanScalarFieldEnum[]
  }


  /**
   * prakiraancurahhujan findFirstOrThrow
   */
  export type prakiraancurahhujanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which prakiraancurahhujan to fetch.
     */
    where?: prakiraancurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prakiraancurahhujans to fetch.
     */
    orderBy?: prakiraancurahhujanOrderByWithRelationInput | prakiraancurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prakiraancurahhujans.
     */
    cursor?: prakiraancurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prakiraancurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prakiraancurahhujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prakiraancurahhujans.
     */
    distinct?: PrakiraancurahhujanScalarFieldEnum | PrakiraancurahhujanScalarFieldEnum[]
  }


  /**
   * prakiraancurahhujan findMany
   */
  export type prakiraancurahhujanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * Filter, which prakiraancurahhujans to fetch.
     */
    where?: prakiraancurahhujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prakiraancurahhujans to fetch.
     */
    orderBy?: prakiraancurahhujanOrderByWithRelationInput | prakiraancurahhujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prakiraancurahhujans.
     */
    cursor?: prakiraancurahhujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prakiraancurahhujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prakiraancurahhujans.
     */
    skip?: number
    distinct?: PrakiraancurahhujanScalarFieldEnum | PrakiraancurahhujanScalarFieldEnum[]
  }


  /**
   * prakiraancurahhujan create
   */
  export type prakiraancurahhujanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * The data needed to create a prakiraancurahhujan.
     */
    data: XOR<prakiraancurahhujanCreateInput, prakiraancurahhujanUncheckedCreateInput>
  }


  /**
   * prakiraancurahhujan createMany
   */
  export type prakiraancurahhujanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prakiraancurahhujans.
     */
    data: prakiraancurahhujanCreateManyInput | prakiraancurahhujanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * prakiraancurahhujan update
   */
  export type prakiraancurahhujanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * The data needed to update a prakiraancurahhujan.
     */
    data: XOR<prakiraancurahhujanUpdateInput, prakiraancurahhujanUncheckedUpdateInput>
    /**
     * Choose, which prakiraancurahhujan to update.
     */
    where: prakiraancurahhujanWhereUniqueInput
  }


  /**
   * prakiraancurahhujan updateMany
   */
  export type prakiraancurahhujanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prakiraancurahhujans.
     */
    data: XOR<prakiraancurahhujanUpdateManyMutationInput, prakiraancurahhujanUncheckedUpdateManyInput>
    /**
     * Filter which prakiraancurahhujans to update
     */
    where?: prakiraancurahhujanWhereInput
  }


  /**
   * prakiraancurahhujan upsert
   */
  export type prakiraancurahhujanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * The filter to search for the prakiraancurahhujan to update in case it exists.
     */
    where: prakiraancurahhujanWhereUniqueInput
    /**
     * In case the prakiraancurahhujan found by the `where` argument doesn't exist, create a new prakiraancurahhujan with this data.
     */
    create: XOR<prakiraancurahhujanCreateInput, prakiraancurahhujanUncheckedCreateInput>
    /**
     * In case the prakiraancurahhujan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prakiraancurahhujanUpdateInput, prakiraancurahhujanUncheckedUpdateInput>
  }


  /**
   * prakiraancurahhujan delete
   */
  export type prakiraancurahhujanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
    /**
     * Filter which prakiraancurahhujan to delete.
     */
    where: prakiraancurahhujanWhereUniqueInput
  }


  /**
   * prakiraancurahhujan deleteMany
   */
  export type prakiraancurahhujanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prakiraancurahhujans to delete
     */
    where?: prakiraancurahhujanWhereInput
  }


  /**
   * prakiraancurahhujan without action
   */
  export type prakiraancurahhujanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prakiraancurahhujan
     */
    select?: prakiraancurahhujanSelect<ExtArgs> | null
  }



  /**
   * Model haritanpahujan
   */

  export type AggregateHaritanpahujan = {
    _count: HaritanpahujanCountAggregateOutputType | null
    _avg: HaritanpahujanAvgAggregateOutputType | null
    _sum: HaritanpahujanSumAggregateOutputType | null
    _min: HaritanpahujanMinAggregateOutputType | null
    _max: HaritanpahujanMaxAggregateOutputType | null
  }

  export type HaritanpahujanAvgAggregateOutputType = {
    id: number | null
  }

  export type HaritanpahujanSumAggregateOutputType = {
    id: number | null
  }

  export type HaritanpahujanMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HaritanpahujanMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HaritanpahujanCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HaritanpahujanAvgAggregateInputType = {
    id?: true
  }

  export type HaritanpahujanSumAggregateInputType = {
    id?: true
  }

  export type HaritanpahujanMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HaritanpahujanMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HaritanpahujanCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HaritanpahujanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which haritanpahujan to aggregate.
     */
    where?: haritanpahujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of haritanpahujans to fetch.
     */
    orderBy?: haritanpahujanOrderByWithRelationInput | haritanpahujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: haritanpahujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` haritanpahujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` haritanpahujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned haritanpahujans
    **/
    _count?: true | HaritanpahujanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HaritanpahujanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HaritanpahujanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HaritanpahujanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HaritanpahujanMaxAggregateInputType
  }

  export type GetHaritanpahujanAggregateType<T extends HaritanpahujanAggregateArgs> = {
        [P in keyof T & keyof AggregateHaritanpahujan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHaritanpahujan[P]>
      : GetScalarType<T[P], AggregateHaritanpahujan[P]>
  }




  export type haritanpahujanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: haritanpahujanWhereInput
    orderBy?: haritanpahujanOrderByWithAggregationInput | haritanpahujanOrderByWithAggregationInput[]
    by: HaritanpahujanScalarFieldEnum[] | HaritanpahujanScalarFieldEnum
    having?: haritanpahujanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HaritanpahujanCountAggregateInputType | true
    _avg?: HaritanpahujanAvgAggregateInputType
    _sum?: HaritanpahujanSumAggregateInputType
    _min?: HaritanpahujanMinAggregateInputType
    _max?: HaritanpahujanMaxAggregateInputType
  }

  export type HaritanpahujanGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: HaritanpahujanCountAggregateOutputType | null
    _avg: HaritanpahujanAvgAggregateOutputType | null
    _sum: HaritanpahujanSumAggregateOutputType | null
    _min: HaritanpahujanMinAggregateOutputType | null
    _max: HaritanpahujanMaxAggregateOutputType | null
  }

  type GetHaritanpahujanGroupByPayload<T extends haritanpahujanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HaritanpahujanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HaritanpahujanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HaritanpahujanGroupByOutputType[P]>
            : GetScalarType<T[P], HaritanpahujanGroupByOutputType[P]>
        }
      >
    >


  export type haritanpahujanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["haritanpahujan"]>

  export type haritanpahujanSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $haritanpahujanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "haritanpahujan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["haritanpahujan"]>
    composites: {}
  }


  type haritanpahujanGetPayload<S extends boolean | null | undefined | haritanpahujanDefaultArgs> = $Result.GetResult<Prisma.$haritanpahujanPayload, S>

  type haritanpahujanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<haritanpahujanFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: HaritanpahujanCountAggregateInputType | true
    }

  export interface haritanpahujanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['haritanpahujan'], meta: { name: 'haritanpahujan' } }
    /**
     * Find zero or one Haritanpahujan that matches the filter.
     * @param {haritanpahujanFindUniqueArgs} args - Arguments to find a Haritanpahujan
     * @example
     * // Get one Haritanpahujan
     * const haritanpahujan = await prisma.haritanpahujan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends haritanpahujanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, haritanpahujanFindUniqueArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Haritanpahujan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {haritanpahujanFindUniqueOrThrowArgs} args - Arguments to find a Haritanpahujan
     * @example
     * // Get one Haritanpahujan
     * const haritanpahujan = await prisma.haritanpahujan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends haritanpahujanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, haritanpahujanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Haritanpahujan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {haritanpahujanFindFirstArgs} args - Arguments to find a Haritanpahujan
     * @example
     * // Get one Haritanpahujan
     * const haritanpahujan = await prisma.haritanpahujan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends haritanpahujanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, haritanpahujanFindFirstArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Haritanpahujan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {haritanpahujanFindFirstOrThrowArgs} args - Arguments to find a Haritanpahujan
     * @example
     * // Get one Haritanpahujan
     * const haritanpahujan = await prisma.haritanpahujan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends haritanpahujanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, haritanpahujanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Haritanpahujans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {haritanpahujanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Haritanpahujans
     * const haritanpahujans = await prisma.haritanpahujan.findMany()
     * 
     * // Get first 10 Haritanpahujans
     * const haritanpahujans = await prisma.haritanpahujan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const haritanpahujanWithIdOnly = await prisma.haritanpahujan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends haritanpahujanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, haritanpahujanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Haritanpahujan.
     * @param {haritanpahujanCreateArgs} args - Arguments to create a Haritanpahujan.
     * @example
     * // Create one Haritanpahujan
     * const Haritanpahujan = await prisma.haritanpahujan.create({
     *   data: {
     *     // ... data to create a Haritanpahujan
     *   }
     * })
     * 
    **/
    create<T extends haritanpahujanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, haritanpahujanCreateArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Haritanpahujans.
     *     @param {haritanpahujanCreateManyArgs} args - Arguments to create many Haritanpahujans.
     *     @example
     *     // Create many Haritanpahujans
     *     const haritanpahujan = await prisma.haritanpahujan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends haritanpahujanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, haritanpahujanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Haritanpahujan.
     * @param {haritanpahujanDeleteArgs} args - Arguments to delete one Haritanpahujan.
     * @example
     * // Delete one Haritanpahujan
     * const Haritanpahujan = await prisma.haritanpahujan.delete({
     *   where: {
     *     // ... filter to delete one Haritanpahujan
     *   }
     * })
     * 
    **/
    delete<T extends haritanpahujanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, haritanpahujanDeleteArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Haritanpahujan.
     * @param {haritanpahujanUpdateArgs} args - Arguments to update one Haritanpahujan.
     * @example
     * // Update one Haritanpahujan
     * const haritanpahujan = await prisma.haritanpahujan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends haritanpahujanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, haritanpahujanUpdateArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Haritanpahujans.
     * @param {haritanpahujanDeleteManyArgs} args - Arguments to filter Haritanpahujans to delete.
     * @example
     * // Delete a few Haritanpahujans
     * const { count } = await prisma.haritanpahujan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends haritanpahujanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, haritanpahujanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Haritanpahujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {haritanpahujanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Haritanpahujans
     * const haritanpahujan = await prisma.haritanpahujan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends haritanpahujanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, haritanpahujanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Haritanpahujan.
     * @param {haritanpahujanUpsertArgs} args - Arguments to update or create a Haritanpahujan.
     * @example
     * // Update or create a Haritanpahujan
     * const haritanpahujan = await prisma.haritanpahujan.upsert({
     *   create: {
     *     // ... data to create a Haritanpahujan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Haritanpahujan we want to update
     *   }
     * })
    **/
    upsert<T extends haritanpahujanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, haritanpahujanUpsertArgs<ExtArgs>>
    ): Prisma__haritanpahujanClient<$Result.GetResult<Prisma.$haritanpahujanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Haritanpahujans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {haritanpahujanCountArgs} args - Arguments to filter Haritanpahujans to count.
     * @example
     * // Count the number of Haritanpahujans
     * const count = await prisma.haritanpahujan.count({
     *   where: {
     *     // ... the filter for the Haritanpahujans we want to count
     *   }
     * })
    **/
    count<T extends haritanpahujanCountArgs>(
      args?: Subset<T, haritanpahujanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HaritanpahujanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Haritanpahujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HaritanpahujanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HaritanpahujanAggregateArgs>(args: Subset<T, HaritanpahujanAggregateArgs>): Prisma.PrismaPromise<GetHaritanpahujanAggregateType<T>>

    /**
     * Group by Haritanpahujan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {haritanpahujanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends haritanpahujanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: haritanpahujanGroupByArgs['orderBy'] }
        : { orderBy?: haritanpahujanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, haritanpahujanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHaritanpahujanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the haritanpahujan model
   */
  readonly fields: haritanpahujanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for haritanpahujan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__haritanpahujanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the haritanpahujan model
   */ 
  interface haritanpahujanFieldRefs {
    readonly id: FieldRef<"haritanpahujan", 'Int'>
    readonly name: FieldRef<"haritanpahujan", 'DateTime'>
    readonly foto: FieldRef<"haritanpahujan", 'String'>
    readonly url: FieldRef<"haritanpahujan", 'String'>
    readonly createdAt: FieldRef<"haritanpahujan", 'DateTime'>
    readonly updatedAt: FieldRef<"haritanpahujan", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * haritanpahujan findUnique
   */
  export type haritanpahujanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * Filter, which haritanpahujan to fetch.
     */
    where: haritanpahujanWhereUniqueInput
  }


  /**
   * haritanpahujan findUniqueOrThrow
   */
  export type haritanpahujanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * Filter, which haritanpahujan to fetch.
     */
    where: haritanpahujanWhereUniqueInput
  }


  /**
   * haritanpahujan findFirst
   */
  export type haritanpahujanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * Filter, which haritanpahujan to fetch.
     */
    where?: haritanpahujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of haritanpahujans to fetch.
     */
    orderBy?: haritanpahujanOrderByWithRelationInput | haritanpahujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for haritanpahujans.
     */
    cursor?: haritanpahujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` haritanpahujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` haritanpahujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of haritanpahujans.
     */
    distinct?: HaritanpahujanScalarFieldEnum | HaritanpahujanScalarFieldEnum[]
  }


  /**
   * haritanpahujan findFirstOrThrow
   */
  export type haritanpahujanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * Filter, which haritanpahujan to fetch.
     */
    where?: haritanpahujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of haritanpahujans to fetch.
     */
    orderBy?: haritanpahujanOrderByWithRelationInput | haritanpahujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for haritanpahujans.
     */
    cursor?: haritanpahujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` haritanpahujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` haritanpahujans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of haritanpahujans.
     */
    distinct?: HaritanpahujanScalarFieldEnum | HaritanpahujanScalarFieldEnum[]
  }


  /**
   * haritanpahujan findMany
   */
  export type haritanpahujanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * Filter, which haritanpahujans to fetch.
     */
    where?: haritanpahujanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of haritanpahujans to fetch.
     */
    orderBy?: haritanpahujanOrderByWithRelationInput | haritanpahujanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing haritanpahujans.
     */
    cursor?: haritanpahujanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` haritanpahujans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` haritanpahujans.
     */
    skip?: number
    distinct?: HaritanpahujanScalarFieldEnum | HaritanpahujanScalarFieldEnum[]
  }


  /**
   * haritanpahujan create
   */
  export type haritanpahujanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * The data needed to create a haritanpahujan.
     */
    data: XOR<haritanpahujanCreateInput, haritanpahujanUncheckedCreateInput>
  }


  /**
   * haritanpahujan createMany
   */
  export type haritanpahujanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many haritanpahujans.
     */
    data: haritanpahujanCreateManyInput | haritanpahujanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * haritanpahujan update
   */
  export type haritanpahujanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * The data needed to update a haritanpahujan.
     */
    data: XOR<haritanpahujanUpdateInput, haritanpahujanUncheckedUpdateInput>
    /**
     * Choose, which haritanpahujan to update.
     */
    where: haritanpahujanWhereUniqueInput
  }


  /**
   * haritanpahujan updateMany
   */
  export type haritanpahujanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update haritanpahujans.
     */
    data: XOR<haritanpahujanUpdateManyMutationInput, haritanpahujanUncheckedUpdateManyInput>
    /**
     * Filter which haritanpahujans to update
     */
    where?: haritanpahujanWhereInput
  }


  /**
   * haritanpahujan upsert
   */
  export type haritanpahujanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * The filter to search for the haritanpahujan to update in case it exists.
     */
    where: haritanpahujanWhereUniqueInput
    /**
     * In case the haritanpahujan found by the `where` argument doesn't exist, create a new haritanpahujan with this data.
     */
    create: XOR<haritanpahujanCreateInput, haritanpahujanUncheckedCreateInput>
    /**
     * In case the haritanpahujan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<haritanpahujanUpdateInput, haritanpahujanUncheckedUpdateInput>
  }


  /**
   * haritanpahujan delete
   */
  export type haritanpahujanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
    /**
     * Filter which haritanpahujan to delete.
     */
    where: haritanpahujanWhereUniqueInput
  }


  /**
   * haritanpahujan deleteMany
   */
  export type haritanpahujanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which haritanpahujans to delete
     */
    where?: haritanpahujanWhereInput
  }


  /**
   * haritanpahujan without action
   */
  export type haritanpahujanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the haritanpahujan
     */
    select?: haritanpahujanSelect<ExtArgs> | null
  }



  /**
   * Model normalmusim
   */

  export type AggregateNormalmusim = {
    _count: NormalmusimCountAggregateOutputType | null
    _avg: NormalmusimAvgAggregateOutputType | null
    _sum: NormalmusimSumAggregateOutputType | null
    _min: NormalmusimMinAggregateOutputType | null
    _max: NormalmusimMaxAggregateOutputType | null
  }

  export type NormalmusimAvgAggregateOutputType = {
    id: number | null
  }

  export type NormalmusimSumAggregateOutputType = {
    id: number | null
  }

  export type NormalmusimMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NormalmusimMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NormalmusimCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NormalmusimAvgAggregateInputType = {
    id?: true
  }

  export type NormalmusimSumAggregateInputType = {
    id?: true
  }

  export type NormalmusimMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NormalmusimMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NormalmusimCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NormalmusimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which normalmusim to aggregate.
     */
    where?: normalmusimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of normalmusims to fetch.
     */
    orderBy?: normalmusimOrderByWithRelationInput | normalmusimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: normalmusimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` normalmusims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` normalmusims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned normalmusims
    **/
    _count?: true | NormalmusimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NormalmusimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NormalmusimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NormalmusimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NormalmusimMaxAggregateInputType
  }

  export type GetNormalmusimAggregateType<T extends NormalmusimAggregateArgs> = {
        [P in keyof T & keyof AggregateNormalmusim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNormalmusim[P]>
      : GetScalarType<T[P], AggregateNormalmusim[P]>
  }




  export type normalmusimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: normalmusimWhereInput
    orderBy?: normalmusimOrderByWithAggregationInput | normalmusimOrderByWithAggregationInput[]
    by: NormalmusimScalarFieldEnum[] | NormalmusimScalarFieldEnum
    having?: normalmusimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NormalmusimCountAggregateInputType | true
    _avg?: NormalmusimAvgAggregateInputType
    _sum?: NormalmusimSumAggregateInputType
    _min?: NormalmusimMinAggregateInputType
    _max?: NormalmusimMaxAggregateInputType
  }

  export type NormalmusimGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: NormalmusimCountAggregateOutputType | null
    _avg: NormalmusimAvgAggregateOutputType | null
    _sum: NormalmusimSumAggregateOutputType | null
    _min: NormalmusimMinAggregateOutputType | null
    _max: NormalmusimMaxAggregateOutputType | null
  }

  type GetNormalmusimGroupByPayload<T extends normalmusimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NormalmusimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NormalmusimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NormalmusimGroupByOutputType[P]>
            : GetScalarType<T[P], NormalmusimGroupByOutputType[P]>
        }
      >
    >


  export type normalmusimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["normalmusim"]>

  export type normalmusimSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $normalmusimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "normalmusim"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["normalmusim"]>
    composites: {}
  }


  type normalmusimGetPayload<S extends boolean | null | undefined | normalmusimDefaultArgs> = $Result.GetResult<Prisma.$normalmusimPayload, S>

  type normalmusimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<normalmusimFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NormalmusimCountAggregateInputType | true
    }

  export interface normalmusimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['normalmusim'], meta: { name: 'normalmusim' } }
    /**
     * Find zero or one Normalmusim that matches the filter.
     * @param {normalmusimFindUniqueArgs} args - Arguments to find a Normalmusim
     * @example
     * // Get one Normalmusim
     * const normalmusim = await prisma.normalmusim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends normalmusimFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, normalmusimFindUniqueArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Normalmusim that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {normalmusimFindUniqueOrThrowArgs} args - Arguments to find a Normalmusim
     * @example
     * // Get one Normalmusim
     * const normalmusim = await prisma.normalmusim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends normalmusimFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, normalmusimFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Normalmusim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {normalmusimFindFirstArgs} args - Arguments to find a Normalmusim
     * @example
     * // Get one Normalmusim
     * const normalmusim = await prisma.normalmusim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends normalmusimFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, normalmusimFindFirstArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Normalmusim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {normalmusimFindFirstOrThrowArgs} args - Arguments to find a Normalmusim
     * @example
     * // Get one Normalmusim
     * const normalmusim = await prisma.normalmusim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends normalmusimFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, normalmusimFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Normalmusims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {normalmusimFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Normalmusims
     * const normalmusims = await prisma.normalmusim.findMany()
     * 
     * // Get first 10 Normalmusims
     * const normalmusims = await prisma.normalmusim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const normalmusimWithIdOnly = await prisma.normalmusim.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends normalmusimFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, normalmusimFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Normalmusim.
     * @param {normalmusimCreateArgs} args - Arguments to create a Normalmusim.
     * @example
     * // Create one Normalmusim
     * const Normalmusim = await prisma.normalmusim.create({
     *   data: {
     *     // ... data to create a Normalmusim
     *   }
     * })
     * 
    **/
    create<T extends normalmusimCreateArgs<ExtArgs>>(
      args: SelectSubset<T, normalmusimCreateArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Normalmusims.
     *     @param {normalmusimCreateManyArgs} args - Arguments to create many Normalmusims.
     *     @example
     *     // Create many Normalmusims
     *     const normalmusim = await prisma.normalmusim.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends normalmusimCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, normalmusimCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Normalmusim.
     * @param {normalmusimDeleteArgs} args - Arguments to delete one Normalmusim.
     * @example
     * // Delete one Normalmusim
     * const Normalmusim = await prisma.normalmusim.delete({
     *   where: {
     *     // ... filter to delete one Normalmusim
     *   }
     * })
     * 
    **/
    delete<T extends normalmusimDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, normalmusimDeleteArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Normalmusim.
     * @param {normalmusimUpdateArgs} args - Arguments to update one Normalmusim.
     * @example
     * // Update one Normalmusim
     * const normalmusim = await prisma.normalmusim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends normalmusimUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, normalmusimUpdateArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Normalmusims.
     * @param {normalmusimDeleteManyArgs} args - Arguments to filter Normalmusims to delete.
     * @example
     * // Delete a few Normalmusims
     * const { count } = await prisma.normalmusim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends normalmusimDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, normalmusimDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Normalmusims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {normalmusimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Normalmusims
     * const normalmusim = await prisma.normalmusim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends normalmusimUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, normalmusimUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Normalmusim.
     * @param {normalmusimUpsertArgs} args - Arguments to update or create a Normalmusim.
     * @example
     * // Update or create a Normalmusim
     * const normalmusim = await prisma.normalmusim.upsert({
     *   create: {
     *     // ... data to create a Normalmusim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Normalmusim we want to update
     *   }
     * })
    **/
    upsert<T extends normalmusimUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, normalmusimUpsertArgs<ExtArgs>>
    ): Prisma__normalmusimClient<$Result.GetResult<Prisma.$normalmusimPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Normalmusims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {normalmusimCountArgs} args - Arguments to filter Normalmusims to count.
     * @example
     * // Count the number of Normalmusims
     * const count = await prisma.normalmusim.count({
     *   where: {
     *     // ... the filter for the Normalmusims we want to count
     *   }
     * })
    **/
    count<T extends normalmusimCountArgs>(
      args?: Subset<T, normalmusimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NormalmusimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Normalmusim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NormalmusimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NormalmusimAggregateArgs>(args: Subset<T, NormalmusimAggregateArgs>): Prisma.PrismaPromise<GetNormalmusimAggregateType<T>>

    /**
     * Group by Normalmusim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {normalmusimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends normalmusimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: normalmusimGroupByArgs['orderBy'] }
        : { orderBy?: normalmusimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, normalmusimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNormalmusimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the normalmusim model
   */
  readonly fields: normalmusimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for normalmusim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__normalmusimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the normalmusim model
   */ 
  interface normalmusimFieldRefs {
    readonly id: FieldRef<"normalmusim", 'Int'>
    readonly name: FieldRef<"normalmusim", 'DateTime'>
    readonly foto: FieldRef<"normalmusim", 'String'>
    readonly url: FieldRef<"normalmusim", 'String'>
    readonly createdAt: FieldRef<"normalmusim", 'DateTime'>
    readonly updatedAt: FieldRef<"normalmusim", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * normalmusim findUnique
   */
  export type normalmusimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * Filter, which normalmusim to fetch.
     */
    where: normalmusimWhereUniqueInput
  }


  /**
   * normalmusim findUniqueOrThrow
   */
  export type normalmusimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * Filter, which normalmusim to fetch.
     */
    where: normalmusimWhereUniqueInput
  }


  /**
   * normalmusim findFirst
   */
  export type normalmusimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * Filter, which normalmusim to fetch.
     */
    where?: normalmusimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of normalmusims to fetch.
     */
    orderBy?: normalmusimOrderByWithRelationInput | normalmusimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for normalmusims.
     */
    cursor?: normalmusimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` normalmusims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` normalmusims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of normalmusims.
     */
    distinct?: NormalmusimScalarFieldEnum | NormalmusimScalarFieldEnum[]
  }


  /**
   * normalmusim findFirstOrThrow
   */
  export type normalmusimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * Filter, which normalmusim to fetch.
     */
    where?: normalmusimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of normalmusims to fetch.
     */
    orderBy?: normalmusimOrderByWithRelationInput | normalmusimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for normalmusims.
     */
    cursor?: normalmusimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` normalmusims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` normalmusims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of normalmusims.
     */
    distinct?: NormalmusimScalarFieldEnum | NormalmusimScalarFieldEnum[]
  }


  /**
   * normalmusim findMany
   */
  export type normalmusimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * Filter, which normalmusims to fetch.
     */
    where?: normalmusimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of normalmusims to fetch.
     */
    orderBy?: normalmusimOrderByWithRelationInput | normalmusimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing normalmusims.
     */
    cursor?: normalmusimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` normalmusims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` normalmusims.
     */
    skip?: number
    distinct?: NormalmusimScalarFieldEnum | NormalmusimScalarFieldEnum[]
  }


  /**
   * normalmusim create
   */
  export type normalmusimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * The data needed to create a normalmusim.
     */
    data: XOR<normalmusimCreateInput, normalmusimUncheckedCreateInput>
  }


  /**
   * normalmusim createMany
   */
  export type normalmusimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many normalmusims.
     */
    data: normalmusimCreateManyInput | normalmusimCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * normalmusim update
   */
  export type normalmusimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * The data needed to update a normalmusim.
     */
    data: XOR<normalmusimUpdateInput, normalmusimUncheckedUpdateInput>
    /**
     * Choose, which normalmusim to update.
     */
    where: normalmusimWhereUniqueInput
  }


  /**
   * normalmusim updateMany
   */
  export type normalmusimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update normalmusims.
     */
    data: XOR<normalmusimUpdateManyMutationInput, normalmusimUncheckedUpdateManyInput>
    /**
     * Filter which normalmusims to update
     */
    where?: normalmusimWhereInput
  }


  /**
   * normalmusim upsert
   */
  export type normalmusimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * The filter to search for the normalmusim to update in case it exists.
     */
    where: normalmusimWhereUniqueInput
    /**
     * In case the normalmusim found by the `where` argument doesn't exist, create a new normalmusim with this data.
     */
    create: XOR<normalmusimCreateInput, normalmusimUncheckedCreateInput>
    /**
     * In case the normalmusim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<normalmusimUpdateInput, normalmusimUncheckedUpdateInput>
  }


  /**
   * normalmusim delete
   */
  export type normalmusimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
    /**
     * Filter which normalmusim to delete.
     */
    where: normalmusimWhereUniqueInput
  }


  /**
   * normalmusim deleteMany
   */
  export type normalmusimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which normalmusims to delete
     */
    where?: normalmusimWhereInput
  }


  /**
   * normalmusim without action
   */
  export type normalmusimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the normalmusim
     */
    select?: normalmusimSelect<ExtArgs> | null
  }



  /**
   * Model kritiksaran
   */

  export type AggregateKritiksaran = {
    _count: KritiksaranCountAggregateOutputType | null
    _avg: KritiksaranAvgAggregateOutputType | null
    _sum: KritiksaranSumAggregateOutputType | null
    _min: KritiksaranMinAggregateOutputType | null
    _max: KritiksaranMaxAggregateOutputType | null
  }

  export type KritiksaranAvgAggregateOutputType = {
    id: number | null
  }

  export type KritiksaranSumAggregateOutputType = {
    id: number | null
  }

  export type KritiksaranMinAggregateOutputType = {
    id: number | null
    nama: string | null
    email: string | null
    nohp: string | null
    kritik: string | null
    saran: string | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type KritiksaranMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    email: string | null
    nohp: string | null
    kritik: string | null
    saran: string | null
    createAt: Date | null
    updatedAt: Date | null
  }

  export type KritiksaranCountAggregateOutputType = {
    id: number
    nama: number
    email: number
    nohp: number
    kritik: number
    saran: number
    createAt: number
    updatedAt: number
    _all: number
  }


  export type KritiksaranAvgAggregateInputType = {
    id?: true
  }

  export type KritiksaranSumAggregateInputType = {
    id?: true
  }

  export type KritiksaranMinAggregateInputType = {
    id?: true
    nama?: true
    email?: true
    nohp?: true
    kritik?: true
    saran?: true
    createAt?: true
    updatedAt?: true
  }

  export type KritiksaranMaxAggregateInputType = {
    id?: true
    nama?: true
    email?: true
    nohp?: true
    kritik?: true
    saran?: true
    createAt?: true
    updatedAt?: true
  }

  export type KritiksaranCountAggregateInputType = {
    id?: true
    nama?: true
    email?: true
    nohp?: true
    kritik?: true
    saran?: true
    createAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KritiksaranAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kritiksaran to aggregate.
     */
    where?: kritiksaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kritiksarans to fetch.
     */
    orderBy?: kritiksaranOrderByWithRelationInput | kritiksaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kritiksaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kritiksarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kritiksarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kritiksarans
    **/
    _count?: true | KritiksaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KritiksaranAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KritiksaranSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KritiksaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KritiksaranMaxAggregateInputType
  }

  export type GetKritiksaranAggregateType<T extends KritiksaranAggregateArgs> = {
        [P in keyof T & keyof AggregateKritiksaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKritiksaran[P]>
      : GetScalarType<T[P], AggregateKritiksaran[P]>
  }




  export type kritiksaranGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kritiksaranWhereInput
    orderBy?: kritiksaranOrderByWithAggregationInput | kritiksaranOrderByWithAggregationInput[]
    by: KritiksaranScalarFieldEnum[] | KritiksaranScalarFieldEnum
    having?: kritiksaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KritiksaranCountAggregateInputType | true
    _avg?: KritiksaranAvgAggregateInputType
    _sum?: KritiksaranSumAggregateInputType
    _min?: KritiksaranMinAggregateInputType
    _max?: KritiksaranMaxAggregateInputType
  }

  export type KritiksaranGroupByOutputType = {
    id: number
    nama: string
    email: string
    nohp: string
    kritik: string
    saran: string
    createAt: Date
    updatedAt: Date
    _count: KritiksaranCountAggregateOutputType | null
    _avg: KritiksaranAvgAggregateOutputType | null
    _sum: KritiksaranSumAggregateOutputType | null
    _min: KritiksaranMinAggregateOutputType | null
    _max: KritiksaranMaxAggregateOutputType | null
  }

  type GetKritiksaranGroupByPayload<T extends kritiksaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KritiksaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KritiksaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KritiksaranGroupByOutputType[P]>
            : GetScalarType<T[P], KritiksaranGroupByOutputType[P]>
        }
      >
    >


  export type kritiksaranSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    email?: boolean
    nohp?: boolean
    kritik?: boolean
    saran?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kritiksaran"]>

  export type kritiksaranSelectScalar = {
    id?: boolean
    nama?: boolean
    email?: boolean
    nohp?: boolean
    kritik?: boolean
    saran?: boolean
    createAt?: boolean
    updatedAt?: boolean
  }


  export type $kritiksaranPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kritiksaran"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      email: string
      nohp: string
      kritik: string
      saran: string
      createAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kritiksaran"]>
    composites: {}
  }


  type kritiksaranGetPayload<S extends boolean | null | undefined | kritiksaranDefaultArgs> = $Result.GetResult<Prisma.$kritiksaranPayload, S>

  type kritiksaranCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kritiksaranFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: KritiksaranCountAggregateInputType | true
    }

  export interface kritiksaranDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kritiksaran'], meta: { name: 'kritiksaran' } }
    /**
     * Find zero or one Kritiksaran that matches the filter.
     * @param {kritiksaranFindUniqueArgs} args - Arguments to find a Kritiksaran
     * @example
     * // Get one Kritiksaran
     * const kritiksaran = await prisma.kritiksaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kritiksaranFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, kritiksaranFindUniqueArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Kritiksaran that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {kritiksaranFindUniqueOrThrowArgs} args - Arguments to find a Kritiksaran
     * @example
     * // Get one Kritiksaran
     * const kritiksaran = await prisma.kritiksaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kritiksaranFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kritiksaranFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Kritiksaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kritiksaranFindFirstArgs} args - Arguments to find a Kritiksaran
     * @example
     * // Get one Kritiksaran
     * const kritiksaran = await prisma.kritiksaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kritiksaranFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, kritiksaranFindFirstArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Kritiksaran that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kritiksaranFindFirstOrThrowArgs} args - Arguments to find a Kritiksaran
     * @example
     * // Get one Kritiksaran
     * const kritiksaran = await prisma.kritiksaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kritiksaranFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, kritiksaranFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Kritiksarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kritiksaranFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kritiksarans
     * const kritiksarans = await prisma.kritiksaran.findMany()
     * 
     * // Get first 10 Kritiksarans
     * const kritiksarans = await prisma.kritiksaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kritiksaranWithIdOnly = await prisma.kritiksaran.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kritiksaranFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kritiksaranFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Kritiksaran.
     * @param {kritiksaranCreateArgs} args - Arguments to create a Kritiksaran.
     * @example
     * // Create one Kritiksaran
     * const Kritiksaran = await prisma.kritiksaran.create({
     *   data: {
     *     // ... data to create a Kritiksaran
     *   }
     * })
     * 
    **/
    create<T extends kritiksaranCreateArgs<ExtArgs>>(
      args: SelectSubset<T, kritiksaranCreateArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Kritiksarans.
     *     @param {kritiksaranCreateManyArgs} args - Arguments to create many Kritiksarans.
     *     @example
     *     // Create many Kritiksarans
     *     const kritiksaran = await prisma.kritiksaran.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kritiksaranCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kritiksaranCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kritiksaran.
     * @param {kritiksaranDeleteArgs} args - Arguments to delete one Kritiksaran.
     * @example
     * // Delete one Kritiksaran
     * const Kritiksaran = await prisma.kritiksaran.delete({
     *   where: {
     *     // ... filter to delete one Kritiksaran
     *   }
     * })
     * 
    **/
    delete<T extends kritiksaranDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, kritiksaranDeleteArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Kritiksaran.
     * @param {kritiksaranUpdateArgs} args - Arguments to update one Kritiksaran.
     * @example
     * // Update one Kritiksaran
     * const kritiksaran = await prisma.kritiksaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kritiksaranUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, kritiksaranUpdateArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Kritiksarans.
     * @param {kritiksaranDeleteManyArgs} args - Arguments to filter Kritiksarans to delete.
     * @example
     * // Delete a few Kritiksarans
     * const { count } = await prisma.kritiksaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kritiksaranDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, kritiksaranDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kritiksarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kritiksaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kritiksarans
     * const kritiksaran = await prisma.kritiksaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kritiksaranUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, kritiksaranUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kritiksaran.
     * @param {kritiksaranUpsertArgs} args - Arguments to update or create a Kritiksaran.
     * @example
     * // Update or create a Kritiksaran
     * const kritiksaran = await prisma.kritiksaran.upsert({
     *   create: {
     *     // ... data to create a Kritiksaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kritiksaran we want to update
     *   }
     * })
    **/
    upsert<T extends kritiksaranUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, kritiksaranUpsertArgs<ExtArgs>>
    ): Prisma__kritiksaranClient<$Result.GetResult<Prisma.$kritiksaranPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Kritiksarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kritiksaranCountArgs} args - Arguments to filter Kritiksarans to count.
     * @example
     * // Count the number of Kritiksarans
     * const count = await prisma.kritiksaran.count({
     *   where: {
     *     // ... the filter for the Kritiksarans we want to count
     *   }
     * })
    **/
    count<T extends kritiksaranCountArgs>(
      args?: Subset<T, kritiksaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KritiksaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kritiksaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KritiksaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KritiksaranAggregateArgs>(args: Subset<T, KritiksaranAggregateArgs>): Prisma.PrismaPromise<GetKritiksaranAggregateType<T>>

    /**
     * Group by Kritiksaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kritiksaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kritiksaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kritiksaranGroupByArgs['orderBy'] }
        : { orderBy?: kritiksaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kritiksaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKritiksaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kritiksaran model
   */
  readonly fields: kritiksaranFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kritiksaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kritiksaranClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the kritiksaran model
   */ 
  interface kritiksaranFieldRefs {
    readonly id: FieldRef<"kritiksaran", 'Int'>
    readonly nama: FieldRef<"kritiksaran", 'String'>
    readonly email: FieldRef<"kritiksaran", 'String'>
    readonly nohp: FieldRef<"kritiksaran", 'String'>
    readonly kritik: FieldRef<"kritiksaran", 'String'>
    readonly saran: FieldRef<"kritiksaran", 'String'>
    readonly createAt: FieldRef<"kritiksaran", 'DateTime'>
    readonly updatedAt: FieldRef<"kritiksaran", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * kritiksaran findUnique
   */
  export type kritiksaranFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * Filter, which kritiksaran to fetch.
     */
    where: kritiksaranWhereUniqueInput
  }


  /**
   * kritiksaran findUniqueOrThrow
   */
  export type kritiksaranFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * Filter, which kritiksaran to fetch.
     */
    where: kritiksaranWhereUniqueInput
  }


  /**
   * kritiksaran findFirst
   */
  export type kritiksaranFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * Filter, which kritiksaran to fetch.
     */
    where?: kritiksaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kritiksarans to fetch.
     */
    orderBy?: kritiksaranOrderByWithRelationInput | kritiksaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kritiksarans.
     */
    cursor?: kritiksaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kritiksarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kritiksarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kritiksarans.
     */
    distinct?: KritiksaranScalarFieldEnum | KritiksaranScalarFieldEnum[]
  }


  /**
   * kritiksaran findFirstOrThrow
   */
  export type kritiksaranFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * Filter, which kritiksaran to fetch.
     */
    where?: kritiksaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kritiksarans to fetch.
     */
    orderBy?: kritiksaranOrderByWithRelationInput | kritiksaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kritiksarans.
     */
    cursor?: kritiksaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kritiksarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kritiksarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kritiksarans.
     */
    distinct?: KritiksaranScalarFieldEnum | KritiksaranScalarFieldEnum[]
  }


  /**
   * kritiksaran findMany
   */
  export type kritiksaranFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * Filter, which kritiksarans to fetch.
     */
    where?: kritiksaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kritiksarans to fetch.
     */
    orderBy?: kritiksaranOrderByWithRelationInput | kritiksaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kritiksarans.
     */
    cursor?: kritiksaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kritiksarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kritiksarans.
     */
    skip?: number
    distinct?: KritiksaranScalarFieldEnum | KritiksaranScalarFieldEnum[]
  }


  /**
   * kritiksaran create
   */
  export type kritiksaranCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * The data needed to create a kritiksaran.
     */
    data: XOR<kritiksaranCreateInput, kritiksaranUncheckedCreateInput>
  }


  /**
   * kritiksaran createMany
   */
  export type kritiksaranCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kritiksarans.
     */
    data: kritiksaranCreateManyInput | kritiksaranCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * kritiksaran update
   */
  export type kritiksaranUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * The data needed to update a kritiksaran.
     */
    data: XOR<kritiksaranUpdateInput, kritiksaranUncheckedUpdateInput>
    /**
     * Choose, which kritiksaran to update.
     */
    where: kritiksaranWhereUniqueInput
  }


  /**
   * kritiksaran updateMany
   */
  export type kritiksaranUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kritiksarans.
     */
    data: XOR<kritiksaranUpdateManyMutationInput, kritiksaranUncheckedUpdateManyInput>
    /**
     * Filter which kritiksarans to update
     */
    where?: kritiksaranWhereInput
  }


  /**
   * kritiksaran upsert
   */
  export type kritiksaranUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * The filter to search for the kritiksaran to update in case it exists.
     */
    where: kritiksaranWhereUniqueInput
    /**
     * In case the kritiksaran found by the `where` argument doesn't exist, create a new kritiksaran with this data.
     */
    create: XOR<kritiksaranCreateInput, kritiksaranUncheckedCreateInput>
    /**
     * In case the kritiksaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kritiksaranUpdateInput, kritiksaranUncheckedUpdateInput>
  }


  /**
   * kritiksaran delete
   */
  export type kritiksaranDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
    /**
     * Filter which kritiksaran to delete.
     */
    where: kritiksaranWhereUniqueInput
  }


  /**
   * kritiksaran deleteMany
   */
  export type kritiksaranDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kritiksarans to delete
     */
    where?: kritiksaranWhereInput
  }


  /**
   * kritiksaran without action
   */
  export type kritiksaranDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kritiksaran
     */
    select?: kritiksaranSelect<ExtArgs> | null
  }



  /**
   * Model cuacabesok
   */

  export type AggregateCuacabesok = {
    _count: CuacabesokCountAggregateOutputType | null
    _avg: CuacabesokAvgAggregateOutputType | null
    _sum: CuacabesokSumAggregateOutputType | null
    _min: CuacabesokMinAggregateOutputType | null
    _max: CuacabesokMaxAggregateOutputType | null
  }

  export type CuacabesokAvgAggregateOutputType = {
    id: number | null
  }

  export type CuacabesokSumAggregateOutputType = {
    id: number | null
  }

  export type CuacabesokMinAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuacabesokMaxAggregateOutputType = {
    id: number | null
    name: Date | null
    foto: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuacabesokCountAggregateOutputType = {
    id: number
    name: number
    foto: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CuacabesokAvgAggregateInputType = {
    id?: true
  }

  export type CuacabesokSumAggregateInputType = {
    id?: true
  }

  export type CuacabesokMinAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuacabesokMaxAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuacabesokCountAggregateInputType = {
    id?: true
    name?: true
    foto?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CuacabesokAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cuacabesok to aggregate.
     */
    where?: cuacabesokWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacabesoks to fetch.
     */
    orderBy?: cuacabesokOrderByWithRelationInput | cuacabesokOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cuacabesokWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacabesoks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacabesoks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cuacabesoks
    **/
    _count?: true | CuacabesokCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuacabesokAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuacabesokSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuacabesokMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuacabesokMaxAggregateInputType
  }

  export type GetCuacabesokAggregateType<T extends CuacabesokAggregateArgs> = {
        [P in keyof T & keyof AggregateCuacabesok]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuacabesok[P]>
      : GetScalarType<T[P], AggregateCuacabesok[P]>
  }




  export type cuacabesokGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cuacabesokWhereInput
    orderBy?: cuacabesokOrderByWithAggregationInput | cuacabesokOrderByWithAggregationInput[]
    by: CuacabesokScalarFieldEnum[] | CuacabesokScalarFieldEnum
    having?: cuacabesokScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuacabesokCountAggregateInputType | true
    _avg?: CuacabesokAvgAggregateInputType
    _sum?: CuacabesokSumAggregateInputType
    _min?: CuacabesokMinAggregateInputType
    _max?: CuacabesokMaxAggregateInputType
  }

  export type CuacabesokGroupByOutputType = {
    id: number
    name: Date
    foto: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: CuacabesokCountAggregateOutputType | null
    _avg: CuacabesokAvgAggregateOutputType | null
    _sum: CuacabesokSumAggregateOutputType | null
    _min: CuacabesokMinAggregateOutputType | null
    _max: CuacabesokMaxAggregateOutputType | null
  }

  type GetCuacabesokGroupByPayload<T extends cuacabesokGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuacabesokGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuacabesokGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuacabesokGroupByOutputType[P]>
            : GetScalarType<T[P], CuacabesokGroupByOutputType[P]>
        }
      >
    >


  export type cuacabesokSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cuacabesok"]>

  export type cuacabesokSelectScalar = {
    id?: boolean
    name?: boolean
    foto?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $cuacabesokPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cuacabesok"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: Date
      foto: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cuacabesok"]>
    composites: {}
  }


  type cuacabesokGetPayload<S extends boolean | null | undefined | cuacabesokDefaultArgs> = $Result.GetResult<Prisma.$cuacabesokPayload, S>

  type cuacabesokCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cuacabesokFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CuacabesokCountAggregateInputType | true
    }

  export interface cuacabesokDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cuacabesok'], meta: { name: 'cuacabesok' } }
    /**
     * Find zero or one Cuacabesok that matches the filter.
     * @param {cuacabesokFindUniqueArgs} args - Arguments to find a Cuacabesok
     * @example
     * // Get one Cuacabesok
     * const cuacabesok = await prisma.cuacabesok.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cuacabesokFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cuacabesokFindUniqueArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cuacabesok that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cuacabesokFindUniqueOrThrowArgs} args - Arguments to find a Cuacabesok
     * @example
     * // Get one Cuacabesok
     * const cuacabesok = await prisma.cuacabesok.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cuacabesokFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacabesokFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cuacabesok that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacabesokFindFirstArgs} args - Arguments to find a Cuacabesok
     * @example
     * // Get one Cuacabesok
     * const cuacabesok = await prisma.cuacabesok.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cuacabesokFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacabesokFindFirstArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cuacabesok that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacabesokFindFirstOrThrowArgs} args - Arguments to find a Cuacabesok
     * @example
     * // Get one Cuacabesok
     * const cuacabesok = await prisma.cuacabesok.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cuacabesokFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacabesokFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cuacabesoks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacabesokFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuacabesoks
     * const cuacabesoks = await prisma.cuacabesok.findMany()
     * 
     * // Get first 10 Cuacabesoks
     * const cuacabesoks = await prisma.cuacabesok.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cuacabesokWithIdOnly = await prisma.cuacabesok.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cuacabesokFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacabesokFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cuacabesok.
     * @param {cuacabesokCreateArgs} args - Arguments to create a Cuacabesok.
     * @example
     * // Create one Cuacabesok
     * const Cuacabesok = await prisma.cuacabesok.create({
     *   data: {
     *     // ... data to create a Cuacabesok
     *   }
     * })
     * 
    **/
    create<T extends cuacabesokCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cuacabesokCreateArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cuacabesoks.
     *     @param {cuacabesokCreateManyArgs} args - Arguments to create many Cuacabesoks.
     *     @example
     *     // Create many Cuacabesoks
     *     const cuacabesok = await prisma.cuacabesok.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cuacabesokCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacabesokCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cuacabesok.
     * @param {cuacabesokDeleteArgs} args - Arguments to delete one Cuacabesok.
     * @example
     * // Delete one Cuacabesok
     * const Cuacabesok = await prisma.cuacabesok.delete({
     *   where: {
     *     // ... filter to delete one Cuacabesok
     *   }
     * })
     * 
    **/
    delete<T extends cuacabesokDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cuacabesokDeleteArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cuacabesok.
     * @param {cuacabesokUpdateArgs} args - Arguments to update one Cuacabesok.
     * @example
     * // Update one Cuacabesok
     * const cuacabesok = await prisma.cuacabesok.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cuacabesokUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cuacabesokUpdateArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cuacabesoks.
     * @param {cuacabesokDeleteManyArgs} args - Arguments to filter Cuacabesoks to delete.
     * @example
     * // Delete a few Cuacabesoks
     * const { count } = await prisma.cuacabesok.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cuacabesokDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cuacabesokDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuacabesoks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacabesokUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuacabesoks
     * const cuacabesok = await prisma.cuacabesok.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cuacabesokUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cuacabesokUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cuacabesok.
     * @param {cuacabesokUpsertArgs} args - Arguments to update or create a Cuacabesok.
     * @example
     * // Update or create a Cuacabesok
     * const cuacabesok = await prisma.cuacabesok.upsert({
     *   create: {
     *     // ... data to create a Cuacabesok
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuacabesok we want to update
     *   }
     * })
    **/
    upsert<T extends cuacabesokUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cuacabesokUpsertArgs<ExtArgs>>
    ): Prisma__cuacabesokClient<$Result.GetResult<Prisma.$cuacabesokPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cuacabesoks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacabesokCountArgs} args - Arguments to filter Cuacabesoks to count.
     * @example
     * // Count the number of Cuacabesoks
     * const count = await prisma.cuacabesok.count({
     *   where: {
     *     // ... the filter for the Cuacabesoks we want to count
     *   }
     * })
    **/
    count<T extends cuacabesokCountArgs>(
      args?: Subset<T, cuacabesokCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuacabesokCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuacabesok.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuacabesokAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuacabesokAggregateArgs>(args: Subset<T, CuacabesokAggregateArgs>): Prisma.PrismaPromise<GetCuacabesokAggregateType<T>>

    /**
     * Group by Cuacabesok.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cuacabesokGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cuacabesokGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cuacabesokGroupByArgs['orderBy'] }
        : { orderBy?: cuacabesokGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cuacabesokGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuacabesokGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cuacabesok model
   */
  readonly fields: cuacabesokFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cuacabesok.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cuacabesokClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cuacabesok model
   */ 
  interface cuacabesokFieldRefs {
    readonly id: FieldRef<"cuacabesok", 'Int'>
    readonly name: FieldRef<"cuacabesok", 'DateTime'>
    readonly foto: FieldRef<"cuacabesok", 'String'>
    readonly url: FieldRef<"cuacabesok", 'String'>
    readonly createdAt: FieldRef<"cuacabesok", 'DateTime'>
    readonly updatedAt: FieldRef<"cuacabesok", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * cuacabesok findUnique
   */
  export type cuacabesokFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * Filter, which cuacabesok to fetch.
     */
    where: cuacabesokWhereUniqueInput
  }


  /**
   * cuacabesok findUniqueOrThrow
   */
  export type cuacabesokFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * Filter, which cuacabesok to fetch.
     */
    where: cuacabesokWhereUniqueInput
  }


  /**
   * cuacabesok findFirst
   */
  export type cuacabesokFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * Filter, which cuacabesok to fetch.
     */
    where?: cuacabesokWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacabesoks to fetch.
     */
    orderBy?: cuacabesokOrderByWithRelationInput | cuacabesokOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cuacabesoks.
     */
    cursor?: cuacabesokWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacabesoks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacabesoks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cuacabesoks.
     */
    distinct?: CuacabesokScalarFieldEnum | CuacabesokScalarFieldEnum[]
  }


  /**
   * cuacabesok findFirstOrThrow
   */
  export type cuacabesokFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * Filter, which cuacabesok to fetch.
     */
    where?: cuacabesokWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacabesoks to fetch.
     */
    orderBy?: cuacabesokOrderByWithRelationInput | cuacabesokOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cuacabesoks.
     */
    cursor?: cuacabesokWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacabesoks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacabesoks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cuacabesoks.
     */
    distinct?: CuacabesokScalarFieldEnum | CuacabesokScalarFieldEnum[]
  }


  /**
   * cuacabesok findMany
   */
  export type cuacabesokFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * Filter, which cuacabesoks to fetch.
     */
    where?: cuacabesokWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cuacabesoks to fetch.
     */
    orderBy?: cuacabesokOrderByWithRelationInput | cuacabesokOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cuacabesoks.
     */
    cursor?: cuacabesokWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cuacabesoks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cuacabesoks.
     */
    skip?: number
    distinct?: CuacabesokScalarFieldEnum | CuacabesokScalarFieldEnum[]
  }


  /**
   * cuacabesok create
   */
  export type cuacabesokCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * The data needed to create a cuacabesok.
     */
    data: XOR<cuacabesokCreateInput, cuacabesokUncheckedCreateInput>
  }


  /**
   * cuacabesok createMany
   */
  export type cuacabesokCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cuacabesoks.
     */
    data: cuacabesokCreateManyInput | cuacabesokCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cuacabesok update
   */
  export type cuacabesokUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * The data needed to update a cuacabesok.
     */
    data: XOR<cuacabesokUpdateInput, cuacabesokUncheckedUpdateInput>
    /**
     * Choose, which cuacabesok to update.
     */
    where: cuacabesokWhereUniqueInput
  }


  /**
   * cuacabesok updateMany
   */
  export type cuacabesokUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cuacabesoks.
     */
    data: XOR<cuacabesokUpdateManyMutationInput, cuacabesokUncheckedUpdateManyInput>
    /**
     * Filter which cuacabesoks to update
     */
    where?: cuacabesokWhereInput
  }


  /**
   * cuacabesok upsert
   */
  export type cuacabesokUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * The filter to search for the cuacabesok to update in case it exists.
     */
    where: cuacabesokWhereUniqueInput
    /**
     * In case the cuacabesok found by the `where` argument doesn't exist, create a new cuacabesok with this data.
     */
    create: XOR<cuacabesokCreateInput, cuacabesokUncheckedCreateInput>
    /**
     * In case the cuacabesok was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cuacabesokUpdateInput, cuacabesokUncheckedUpdateInput>
  }


  /**
   * cuacabesok delete
   */
  export type cuacabesokDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
    /**
     * Filter which cuacabesok to delete.
     */
    where: cuacabesokWhereUniqueInput
  }


  /**
   * cuacabesok deleteMany
   */
  export type cuacabesokDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cuacabesoks to delete
     */
    where?: cuacabesokWhereInput
  }


  /**
   * cuacabesok without action
   */
  export type cuacabesokDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cuacabesok
     */
    select?: cuacabesokSelect<ExtArgs> | null
  }



  /**
   * Model peringatandini
   */

  export type AggregatePeringatandini = {
    _count: PeringatandiniCountAggregateOutputType | null
    _avg: PeringatandiniAvgAggregateOutputType | null
    _sum: PeringatandiniSumAggregateOutputType | null
    _min: PeringatandiniMinAggregateOutputType | null
    _max: PeringatandiniMaxAggregateOutputType | null
  }

  export type PeringatandiniAvgAggregateOutputType = {
    id: number | null
  }

  export type PeringatandiniSumAggregateOutputType = {
    id: number | null
  }

  export type PeringatandiniMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    peringatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PeringatandiniMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    peringatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PeringatandiniCountAggregateOutputType = {
    id: number
    tanggal: number
    peringatan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PeringatandiniAvgAggregateInputType = {
    id?: true
  }

  export type PeringatandiniSumAggregateInputType = {
    id?: true
  }

  export type PeringatandiniMinAggregateInputType = {
    id?: true
    tanggal?: true
    peringatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PeringatandiniMaxAggregateInputType = {
    id?: true
    tanggal?: true
    peringatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PeringatandiniCountAggregateInputType = {
    id?: true
    tanggal?: true
    peringatan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PeringatandiniAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which peringatandini to aggregate.
     */
    where?: peringatandiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of peringatandinis to fetch.
     */
    orderBy?: peringatandiniOrderByWithRelationInput | peringatandiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: peringatandiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` peringatandinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` peringatandinis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned peringatandinis
    **/
    _count?: true | PeringatandiniCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeringatandiniAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeringatandiniSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeringatandiniMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeringatandiniMaxAggregateInputType
  }

  export type GetPeringatandiniAggregateType<T extends PeringatandiniAggregateArgs> = {
        [P in keyof T & keyof AggregatePeringatandini]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeringatandini[P]>
      : GetScalarType<T[P], AggregatePeringatandini[P]>
  }




  export type peringatandiniGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: peringatandiniWhereInput
    orderBy?: peringatandiniOrderByWithAggregationInput | peringatandiniOrderByWithAggregationInput[]
    by: PeringatandiniScalarFieldEnum[] | PeringatandiniScalarFieldEnum
    having?: peringatandiniScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeringatandiniCountAggregateInputType | true
    _avg?: PeringatandiniAvgAggregateInputType
    _sum?: PeringatandiniSumAggregateInputType
    _min?: PeringatandiniMinAggregateInputType
    _max?: PeringatandiniMaxAggregateInputType
  }

  export type PeringatandiniGroupByOutputType = {
    id: number
    tanggal: Date
    peringatan: string
    createdAt: Date
    updatedAt: Date
    _count: PeringatandiniCountAggregateOutputType | null
    _avg: PeringatandiniAvgAggregateOutputType | null
    _sum: PeringatandiniSumAggregateOutputType | null
    _min: PeringatandiniMinAggregateOutputType | null
    _max: PeringatandiniMaxAggregateOutputType | null
  }

  type GetPeringatandiniGroupByPayload<T extends peringatandiniGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeringatandiniGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeringatandiniGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeringatandiniGroupByOutputType[P]>
            : GetScalarType<T[P], PeringatandiniGroupByOutputType[P]>
        }
      >
    >


  export type peringatandiniSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    peringatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["peringatandini"]>

  export type peringatandiniSelectScalar = {
    id?: boolean
    tanggal?: boolean
    peringatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $peringatandiniPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "peringatandini"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      peringatan: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["peringatandini"]>
    composites: {}
  }


  type peringatandiniGetPayload<S extends boolean | null | undefined | peringatandiniDefaultArgs> = $Result.GetResult<Prisma.$peringatandiniPayload, S>

  type peringatandiniCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<peringatandiniFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PeringatandiniCountAggregateInputType | true
    }

  export interface peringatandiniDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['peringatandini'], meta: { name: 'peringatandini' } }
    /**
     * Find zero or one Peringatandini that matches the filter.
     * @param {peringatandiniFindUniqueArgs} args - Arguments to find a Peringatandini
     * @example
     * // Get one Peringatandini
     * const peringatandini = await prisma.peringatandini.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends peringatandiniFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, peringatandiniFindUniqueArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Peringatandini that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {peringatandiniFindUniqueOrThrowArgs} args - Arguments to find a Peringatandini
     * @example
     * // Get one Peringatandini
     * const peringatandini = await prisma.peringatandini.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends peringatandiniFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, peringatandiniFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Peringatandini that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {peringatandiniFindFirstArgs} args - Arguments to find a Peringatandini
     * @example
     * // Get one Peringatandini
     * const peringatandini = await prisma.peringatandini.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends peringatandiniFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, peringatandiniFindFirstArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Peringatandini that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {peringatandiniFindFirstOrThrowArgs} args - Arguments to find a Peringatandini
     * @example
     * // Get one Peringatandini
     * const peringatandini = await prisma.peringatandini.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends peringatandiniFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, peringatandiniFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Peringatandinis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {peringatandiniFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Peringatandinis
     * const peringatandinis = await prisma.peringatandini.findMany()
     * 
     * // Get first 10 Peringatandinis
     * const peringatandinis = await prisma.peringatandini.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const peringatandiniWithIdOnly = await prisma.peringatandini.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends peringatandiniFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, peringatandiniFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Peringatandini.
     * @param {peringatandiniCreateArgs} args - Arguments to create a Peringatandini.
     * @example
     * // Create one Peringatandini
     * const Peringatandini = await prisma.peringatandini.create({
     *   data: {
     *     // ... data to create a Peringatandini
     *   }
     * })
     * 
    **/
    create<T extends peringatandiniCreateArgs<ExtArgs>>(
      args: SelectSubset<T, peringatandiniCreateArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Peringatandinis.
     *     @param {peringatandiniCreateManyArgs} args - Arguments to create many Peringatandinis.
     *     @example
     *     // Create many Peringatandinis
     *     const peringatandini = await prisma.peringatandini.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends peringatandiniCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, peringatandiniCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Peringatandini.
     * @param {peringatandiniDeleteArgs} args - Arguments to delete one Peringatandini.
     * @example
     * // Delete one Peringatandini
     * const Peringatandini = await prisma.peringatandini.delete({
     *   where: {
     *     // ... filter to delete one Peringatandini
     *   }
     * })
     * 
    **/
    delete<T extends peringatandiniDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, peringatandiniDeleteArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Peringatandini.
     * @param {peringatandiniUpdateArgs} args - Arguments to update one Peringatandini.
     * @example
     * // Update one Peringatandini
     * const peringatandini = await prisma.peringatandini.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends peringatandiniUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, peringatandiniUpdateArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Peringatandinis.
     * @param {peringatandiniDeleteManyArgs} args - Arguments to filter Peringatandinis to delete.
     * @example
     * // Delete a few Peringatandinis
     * const { count } = await prisma.peringatandini.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends peringatandiniDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, peringatandiniDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Peringatandinis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {peringatandiniUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Peringatandinis
     * const peringatandini = await prisma.peringatandini.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends peringatandiniUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, peringatandiniUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Peringatandini.
     * @param {peringatandiniUpsertArgs} args - Arguments to update or create a Peringatandini.
     * @example
     * // Update or create a Peringatandini
     * const peringatandini = await prisma.peringatandini.upsert({
     *   create: {
     *     // ... data to create a Peringatandini
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Peringatandini we want to update
     *   }
     * })
    **/
    upsert<T extends peringatandiniUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, peringatandiniUpsertArgs<ExtArgs>>
    ): Prisma__peringatandiniClient<$Result.GetResult<Prisma.$peringatandiniPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Peringatandinis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {peringatandiniCountArgs} args - Arguments to filter Peringatandinis to count.
     * @example
     * // Count the number of Peringatandinis
     * const count = await prisma.peringatandini.count({
     *   where: {
     *     // ... the filter for the Peringatandinis we want to count
     *   }
     * })
    **/
    count<T extends peringatandiniCountArgs>(
      args?: Subset<T, peringatandiniCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeringatandiniCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Peringatandini.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeringatandiniAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeringatandiniAggregateArgs>(args: Subset<T, PeringatandiniAggregateArgs>): Prisma.PrismaPromise<GetPeringatandiniAggregateType<T>>

    /**
     * Group by Peringatandini.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {peringatandiniGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends peringatandiniGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: peringatandiniGroupByArgs['orderBy'] }
        : { orderBy?: peringatandiniGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, peringatandiniGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeringatandiniGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the peringatandini model
   */
  readonly fields: peringatandiniFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for peringatandini.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__peringatandiniClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the peringatandini model
   */ 
  interface peringatandiniFieldRefs {
    readonly id: FieldRef<"peringatandini", 'Int'>
    readonly tanggal: FieldRef<"peringatandini", 'DateTime'>
    readonly peringatan: FieldRef<"peringatandini", 'String'>
    readonly createdAt: FieldRef<"peringatandini", 'DateTime'>
    readonly updatedAt: FieldRef<"peringatandini", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * peringatandini findUnique
   */
  export type peringatandiniFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * Filter, which peringatandini to fetch.
     */
    where: peringatandiniWhereUniqueInput
  }


  /**
   * peringatandini findUniqueOrThrow
   */
  export type peringatandiniFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * Filter, which peringatandini to fetch.
     */
    where: peringatandiniWhereUniqueInput
  }


  /**
   * peringatandini findFirst
   */
  export type peringatandiniFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * Filter, which peringatandini to fetch.
     */
    where?: peringatandiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of peringatandinis to fetch.
     */
    orderBy?: peringatandiniOrderByWithRelationInput | peringatandiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for peringatandinis.
     */
    cursor?: peringatandiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` peringatandinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` peringatandinis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of peringatandinis.
     */
    distinct?: PeringatandiniScalarFieldEnum | PeringatandiniScalarFieldEnum[]
  }


  /**
   * peringatandini findFirstOrThrow
   */
  export type peringatandiniFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * Filter, which peringatandini to fetch.
     */
    where?: peringatandiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of peringatandinis to fetch.
     */
    orderBy?: peringatandiniOrderByWithRelationInput | peringatandiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for peringatandinis.
     */
    cursor?: peringatandiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` peringatandinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` peringatandinis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of peringatandinis.
     */
    distinct?: PeringatandiniScalarFieldEnum | PeringatandiniScalarFieldEnum[]
  }


  /**
   * peringatandini findMany
   */
  export type peringatandiniFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * Filter, which peringatandinis to fetch.
     */
    where?: peringatandiniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of peringatandinis to fetch.
     */
    orderBy?: peringatandiniOrderByWithRelationInput | peringatandiniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing peringatandinis.
     */
    cursor?: peringatandiniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` peringatandinis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` peringatandinis.
     */
    skip?: number
    distinct?: PeringatandiniScalarFieldEnum | PeringatandiniScalarFieldEnum[]
  }


  /**
   * peringatandini create
   */
  export type peringatandiniCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * The data needed to create a peringatandini.
     */
    data: XOR<peringatandiniCreateInput, peringatandiniUncheckedCreateInput>
  }


  /**
   * peringatandini createMany
   */
  export type peringatandiniCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many peringatandinis.
     */
    data: peringatandiniCreateManyInput | peringatandiniCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * peringatandini update
   */
  export type peringatandiniUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * The data needed to update a peringatandini.
     */
    data: XOR<peringatandiniUpdateInput, peringatandiniUncheckedUpdateInput>
    /**
     * Choose, which peringatandini to update.
     */
    where: peringatandiniWhereUniqueInput
  }


  /**
   * peringatandini updateMany
   */
  export type peringatandiniUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update peringatandinis.
     */
    data: XOR<peringatandiniUpdateManyMutationInput, peringatandiniUncheckedUpdateManyInput>
    /**
     * Filter which peringatandinis to update
     */
    where?: peringatandiniWhereInput
  }


  /**
   * peringatandini upsert
   */
  export type peringatandiniUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * The filter to search for the peringatandini to update in case it exists.
     */
    where: peringatandiniWhereUniqueInput
    /**
     * In case the peringatandini found by the `where` argument doesn't exist, create a new peringatandini with this data.
     */
    create: XOR<peringatandiniCreateInput, peringatandiniUncheckedCreateInput>
    /**
     * In case the peringatandini was found with the provided `where` argument, update it with this data.
     */
    update: XOR<peringatandiniUpdateInput, peringatandiniUncheckedUpdateInput>
  }


  /**
   * peringatandini delete
   */
  export type peringatandiniDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
    /**
     * Filter which peringatandini to delete.
     */
    where: peringatandiniWhereUniqueInput
  }


  /**
   * peringatandini deleteMany
   */
  export type peringatandiniDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which peringatandinis to delete
     */
    where?: peringatandiniWhereInput
  }


  /**
   * peringatandini without action
   */
  export type peringatandiniDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the peringatandini
     */
    select?: peringatandiniSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ImageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const BuletinTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    buletin: 'buletin',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuletinTableScalarFieldEnum = (typeof BuletinTableScalarFieldEnum)[keyof typeof BuletinTableScalarFieldEnum]


  export const BeritaScalarFieldEnum: {
    id: 'id',
    judul: 'judul',
    tanggal: 'tanggal',
    isi: 'isi',
    gambar: 'gambar',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BeritaScalarFieldEnum = (typeof BeritaScalarFieldEnum)[keyof typeof BeritaScalarFieldEnum]


  export const PegawaiScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    nip: 'nip',
    pangkat: 'pangkat',
    jabatan: 'jabatan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PegawaiScalarFieldEnum = (typeof PegawaiScalarFieldEnum)[keyof typeof PegawaiScalarFieldEnum]


  export const CuacahariiniScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CuacahariiniScalarFieldEnum = (typeof CuacahariiniScalarFieldEnum)[keyof typeof CuacahariiniScalarFieldEnum]


  export const TourismScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourismScalarFieldEnum = (typeof TourismScalarFieldEnum)[keyof typeof TourismScalarFieldEnum]


  export const AnalisiscurahhujanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalisiscurahhujanScalarFieldEnum = (typeof AnalisiscurahhujanScalarFieldEnum)[keyof typeof AnalisiscurahhujanScalarFieldEnum]


  export const AnalisissifathujanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalisissifathujanScalarFieldEnum = (typeof AnalisissifathujanScalarFieldEnum)[keyof typeof AnalisissifathujanScalarFieldEnum]


  export const PrakiraancurahhujanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrakiraancurahhujanScalarFieldEnum = (typeof PrakiraancurahhujanScalarFieldEnum)[keyof typeof PrakiraancurahhujanScalarFieldEnum]


  export const HaritanpahujanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HaritanpahujanScalarFieldEnum = (typeof HaritanpahujanScalarFieldEnum)[keyof typeof HaritanpahujanScalarFieldEnum]


  export const NormalmusimScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NormalmusimScalarFieldEnum = (typeof NormalmusimScalarFieldEnum)[keyof typeof NormalmusimScalarFieldEnum]


  export const KritiksaranScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    email: 'email',
    nohp: 'nohp',
    kritik: 'kritik',
    saran: 'saran',
    createAt: 'createAt',
    updatedAt: 'updatedAt'
  };

  export type KritiksaranScalarFieldEnum = (typeof KritiksaranScalarFieldEnum)[keyof typeof KritiksaranScalarFieldEnum]


  export const CuacabesokScalarFieldEnum: {
    id: 'id',
    name: 'name',
    foto: 'foto',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CuacabesokScalarFieldEnum = (typeof CuacabesokScalarFieldEnum)[keyof typeof CuacabesokScalarFieldEnum]


  export const PeringatandiniScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    peringatan: 'peringatan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PeringatandiniScalarFieldEnum = (typeof PeringatandiniScalarFieldEnum)[keyof typeof PeringatandiniScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: IntFilter<"Image"> | number
    name?: StringFilter<"Image"> | string
    foto?: StringFilter<"Image"> | string
    url?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    name?: StringFilter<"Image"> | string
    foto?: StringFilter<"Image"> | string
    url?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Image"> | number
    name?: StringWithAggregatesFilter<"Image"> | string
    foto?: StringWithAggregatesFilter<"Image"> | string
    url?: StringWithAggregatesFilter<"Image"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
  }

  export type BuletinTableWhereInput = {
    AND?: BuletinTableWhereInput | BuletinTableWhereInput[]
    OR?: BuletinTableWhereInput[]
    NOT?: BuletinTableWhereInput | BuletinTableWhereInput[]
    id?: IntFilter<"BuletinTable"> | number
    name?: StringFilter<"BuletinTable"> | string
    buletin?: StringFilter<"BuletinTable"> | string
    url?: StringFilter<"BuletinTable"> | string
    createdAt?: DateTimeFilter<"BuletinTable"> | Date | string
    updatedAt?: DateTimeFilter<"BuletinTable"> | Date | string
  }

  export type BuletinTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buletin?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuletinTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuletinTableWhereInput | BuletinTableWhereInput[]
    OR?: BuletinTableWhereInput[]
    NOT?: BuletinTableWhereInput | BuletinTableWhereInput[]
    name?: StringFilter<"BuletinTable"> | string
    buletin?: StringFilter<"BuletinTable"> | string
    url?: StringFilter<"BuletinTable"> | string
    createdAt?: DateTimeFilter<"BuletinTable"> | Date | string
    updatedAt?: DateTimeFilter<"BuletinTable"> | Date | string
  }, "id">

  export type BuletinTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    buletin?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuletinTableCountOrderByAggregateInput
    _avg?: BuletinTableAvgOrderByAggregateInput
    _max?: BuletinTableMaxOrderByAggregateInput
    _min?: BuletinTableMinOrderByAggregateInput
    _sum?: BuletinTableSumOrderByAggregateInput
  }

  export type BuletinTableScalarWhereWithAggregatesInput = {
    AND?: BuletinTableScalarWhereWithAggregatesInput | BuletinTableScalarWhereWithAggregatesInput[]
    OR?: BuletinTableScalarWhereWithAggregatesInput[]
    NOT?: BuletinTableScalarWhereWithAggregatesInput | BuletinTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuletinTable"> | number
    name?: StringWithAggregatesFilter<"BuletinTable"> | string
    buletin?: StringWithAggregatesFilter<"BuletinTable"> | string
    url?: StringWithAggregatesFilter<"BuletinTable"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BuletinTable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuletinTable"> | Date | string
  }

  export type beritaWhereInput = {
    AND?: beritaWhereInput | beritaWhereInput[]
    OR?: beritaWhereInput[]
    NOT?: beritaWhereInput | beritaWhereInput[]
    id?: IntFilter<"berita"> | number
    judul?: StringFilter<"berita"> | string
    tanggal?: DateTimeFilter<"berita"> | Date | string
    isi?: StringFilter<"berita"> | string
    gambar?: StringFilter<"berita"> | string
    url?: StringFilter<"berita"> | string
    createdAt?: DateTimeFilter<"berita"> | Date | string
    updatedAt?: DateTimeFilter<"berita"> | Date | string
  }

  export type beritaOrderByWithRelationInput = {
    id?: SortOrder
    judul?: SortOrder
    tanggal?: SortOrder
    isi?: SortOrder
    gambar?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type beritaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: beritaWhereInput | beritaWhereInput[]
    OR?: beritaWhereInput[]
    NOT?: beritaWhereInput | beritaWhereInput[]
    judul?: StringFilter<"berita"> | string
    tanggal?: DateTimeFilter<"berita"> | Date | string
    isi?: StringFilter<"berita"> | string
    gambar?: StringFilter<"berita"> | string
    url?: StringFilter<"berita"> | string
    createdAt?: DateTimeFilter<"berita"> | Date | string
    updatedAt?: DateTimeFilter<"berita"> | Date | string
  }, "id">

  export type beritaOrderByWithAggregationInput = {
    id?: SortOrder
    judul?: SortOrder
    tanggal?: SortOrder
    isi?: SortOrder
    gambar?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: beritaCountOrderByAggregateInput
    _avg?: beritaAvgOrderByAggregateInput
    _max?: beritaMaxOrderByAggregateInput
    _min?: beritaMinOrderByAggregateInput
    _sum?: beritaSumOrderByAggregateInput
  }

  export type beritaScalarWhereWithAggregatesInput = {
    AND?: beritaScalarWhereWithAggregatesInput | beritaScalarWhereWithAggregatesInput[]
    OR?: beritaScalarWhereWithAggregatesInput[]
    NOT?: beritaScalarWhereWithAggregatesInput | beritaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"berita"> | number
    judul?: StringWithAggregatesFilter<"berita"> | string
    tanggal?: DateTimeWithAggregatesFilter<"berita"> | Date | string
    isi?: StringWithAggregatesFilter<"berita"> | string
    gambar?: StringWithAggregatesFilter<"berita"> | string
    url?: StringWithAggregatesFilter<"berita"> | string
    createdAt?: DateTimeWithAggregatesFilter<"berita"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"berita"> | Date | string
  }

  export type pegawaiWhereInput = {
    AND?: pegawaiWhereInput | pegawaiWhereInput[]
    OR?: pegawaiWhereInput[]
    NOT?: pegawaiWhereInput | pegawaiWhereInput[]
    id?: IntFilter<"pegawai"> | number
    nama?: StringFilter<"pegawai"> | string
    nip?: StringFilter<"pegawai"> | string
    pangkat?: StringFilter<"pegawai"> | string
    jabatan?: StringFilter<"pegawai"> | string
    createdAt?: DateTimeFilter<"pegawai"> | Date | string
    updatedAt?: DateTimeFilter<"pegawai"> | Date | string
  }

  export type pegawaiOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    nip?: SortOrder
    pangkat?: SortOrder
    jabatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pegawaiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pegawaiWhereInput | pegawaiWhereInput[]
    OR?: pegawaiWhereInput[]
    NOT?: pegawaiWhereInput | pegawaiWhereInput[]
    nama?: StringFilter<"pegawai"> | string
    nip?: StringFilter<"pegawai"> | string
    pangkat?: StringFilter<"pegawai"> | string
    jabatan?: StringFilter<"pegawai"> | string
    createdAt?: DateTimeFilter<"pegawai"> | Date | string
    updatedAt?: DateTimeFilter<"pegawai"> | Date | string
  }, "id">

  export type pegawaiOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    nip?: SortOrder
    pangkat?: SortOrder
    jabatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pegawaiCountOrderByAggregateInput
    _avg?: pegawaiAvgOrderByAggregateInput
    _max?: pegawaiMaxOrderByAggregateInput
    _min?: pegawaiMinOrderByAggregateInput
    _sum?: pegawaiSumOrderByAggregateInput
  }

  export type pegawaiScalarWhereWithAggregatesInput = {
    AND?: pegawaiScalarWhereWithAggregatesInput | pegawaiScalarWhereWithAggregatesInput[]
    OR?: pegawaiScalarWhereWithAggregatesInput[]
    NOT?: pegawaiScalarWhereWithAggregatesInput | pegawaiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pegawai"> | number
    nama?: StringWithAggregatesFilter<"pegawai"> | string
    nip?: StringWithAggregatesFilter<"pegawai"> | string
    pangkat?: StringWithAggregatesFilter<"pegawai"> | string
    jabatan?: StringWithAggregatesFilter<"pegawai"> | string
    createdAt?: DateTimeWithAggregatesFilter<"pegawai"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pegawai"> | Date | string
  }

  export type cuacahariiniWhereInput = {
    AND?: cuacahariiniWhereInput | cuacahariiniWhereInput[]
    OR?: cuacahariiniWhereInput[]
    NOT?: cuacahariiniWhereInput | cuacahariiniWhereInput[]
    id?: IntFilter<"cuacahariini"> | number
    name?: DateTimeFilter<"cuacahariini"> | Date | string
    foto?: StringFilter<"cuacahariini"> | string
    url?: StringFilter<"cuacahariini"> | string
    createdAt?: DateTimeFilter<"cuacahariini"> | Date | string
    updatedAt?: DateTimeFilter<"cuacahariini"> | Date | string
  }

  export type cuacahariiniOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacahariiniWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cuacahariiniWhereInput | cuacahariiniWhereInput[]
    OR?: cuacahariiniWhereInput[]
    NOT?: cuacahariiniWhereInput | cuacahariiniWhereInput[]
    name?: DateTimeFilter<"cuacahariini"> | Date | string
    foto?: StringFilter<"cuacahariini"> | string
    url?: StringFilter<"cuacahariini"> | string
    createdAt?: DateTimeFilter<"cuacahariini"> | Date | string
    updatedAt?: DateTimeFilter<"cuacahariini"> | Date | string
  }, "id">

  export type cuacahariiniOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cuacahariiniCountOrderByAggregateInput
    _avg?: cuacahariiniAvgOrderByAggregateInput
    _max?: cuacahariiniMaxOrderByAggregateInput
    _min?: cuacahariiniMinOrderByAggregateInput
    _sum?: cuacahariiniSumOrderByAggregateInput
  }

  export type cuacahariiniScalarWhereWithAggregatesInput = {
    AND?: cuacahariiniScalarWhereWithAggregatesInput | cuacahariiniScalarWhereWithAggregatesInput[]
    OR?: cuacahariiniScalarWhereWithAggregatesInput[]
    NOT?: cuacahariiniScalarWhereWithAggregatesInput | cuacahariiniScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cuacahariini"> | number
    name?: DateTimeWithAggregatesFilter<"cuacahariini"> | Date | string
    foto?: StringWithAggregatesFilter<"cuacahariini"> | string
    url?: StringWithAggregatesFilter<"cuacahariini"> | string
    createdAt?: DateTimeWithAggregatesFilter<"cuacahariini"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cuacahariini"> | Date | string
  }

  export type tourismWhereInput = {
    AND?: tourismWhereInput | tourismWhereInput[]
    OR?: tourismWhereInput[]
    NOT?: tourismWhereInput | tourismWhereInput[]
    id?: IntFilter<"tourism"> | number
    name?: DateTimeFilter<"tourism"> | Date | string
    foto?: StringFilter<"tourism"> | string
    url?: StringFilter<"tourism"> | string
    createdAt?: DateTimeFilter<"tourism"> | Date | string
    updatedAt?: DateTimeFilter<"tourism"> | Date | string
  }

  export type tourismOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tourismWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tourismWhereInput | tourismWhereInput[]
    OR?: tourismWhereInput[]
    NOT?: tourismWhereInput | tourismWhereInput[]
    name?: DateTimeFilter<"tourism"> | Date | string
    foto?: StringFilter<"tourism"> | string
    url?: StringFilter<"tourism"> | string
    createdAt?: DateTimeFilter<"tourism"> | Date | string
    updatedAt?: DateTimeFilter<"tourism"> | Date | string
  }, "id">

  export type tourismOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tourismCountOrderByAggregateInput
    _avg?: tourismAvgOrderByAggregateInput
    _max?: tourismMaxOrderByAggregateInput
    _min?: tourismMinOrderByAggregateInput
    _sum?: tourismSumOrderByAggregateInput
  }

  export type tourismScalarWhereWithAggregatesInput = {
    AND?: tourismScalarWhereWithAggregatesInput | tourismScalarWhereWithAggregatesInput[]
    OR?: tourismScalarWhereWithAggregatesInput[]
    NOT?: tourismScalarWhereWithAggregatesInput | tourismScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tourism"> | number
    name?: DateTimeWithAggregatesFilter<"tourism"> | Date | string
    foto?: StringWithAggregatesFilter<"tourism"> | string
    url?: StringWithAggregatesFilter<"tourism"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tourism"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tourism"> | Date | string
  }

  export type analisiscurahhujanWhereInput = {
    AND?: analisiscurahhujanWhereInput | analisiscurahhujanWhereInput[]
    OR?: analisiscurahhujanWhereInput[]
    NOT?: analisiscurahhujanWhereInput | analisiscurahhujanWhereInput[]
    id?: IntFilter<"analisiscurahhujan"> | number
    name?: DateTimeFilter<"analisiscurahhujan"> | Date | string
    foto?: StringFilter<"analisiscurahhujan"> | string
    url?: StringFilter<"analisiscurahhujan"> | string
    createdAt?: DateTimeFilter<"analisiscurahhujan"> | Date | string
    updatedAt?: DateTimeFilter<"analisiscurahhujan"> | Date | string
  }

  export type analisiscurahhujanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisiscurahhujanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: analisiscurahhujanWhereInput | analisiscurahhujanWhereInput[]
    OR?: analisiscurahhujanWhereInput[]
    NOT?: analisiscurahhujanWhereInput | analisiscurahhujanWhereInput[]
    name?: DateTimeFilter<"analisiscurahhujan"> | Date | string
    foto?: StringFilter<"analisiscurahhujan"> | string
    url?: StringFilter<"analisiscurahhujan"> | string
    createdAt?: DateTimeFilter<"analisiscurahhujan"> | Date | string
    updatedAt?: DateTimeFilter<"analisiscurahhujan"> | Date | string
  }, "id">

  export type analisiscurahhujanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: analisiscurahhujanCountOrderByAggregateInput
    _avg?: analisiscurahhujanAvgOrderByAggregateInput
    _max?: analisiscurahhujanMaxOrderByAggregateInput
    _min?: analisiscurahhujanMinOrderByAggregateInput
    _sum?: analisiscurahhujanSumOrderByAggregateInput
  }

  export type analisiscurahhujanScalarWhereWithAggregatesInput = {
    AND?: analisiscurahhujanScalarWhereWithAggregatesInput | analisiscurahhujanScalarWhereWithAggregatesInput[]
    OR?: analisiscurahhujanScalarWhereWithAggregatesInput[]
    NOT?: analisiscurahhujanScalarWhereWithAggregatesInput | analisiscurahhujanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"analisiscurahhujan"> | number
    name?: DateTimeWithAggregatesFilter<"analisiscurahhujan"> | Date | string
    foto?: StringWithAggregatesFilter<"analisiscurahhujan"> | string
    url?: StringWithAggregatesFilter<"analisiscurahhujan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"analisiscurahhujan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"analisiscurahhujan"> | Date | string
  }

  export type analisissifathujanWhereInput = {
    AND?: analisissifathujanWhereInput | analisissifathujanWhereInput[]
    OR?: analisissifathujanWhereInput[]
    NOT?: analisissifathujanWhereInput | analisissifathujanWhereInput[]
    id?: IntFilter<"analisissifathujan"> | number
    name?: DateTimeFilter<"analisissifathujan"> | Date | string
    foto?: StringFilter<"analisissifathujan"> | string
    url?: StringFilter<"analisissifathujan"> | string
    createdAt?: DateTimeFilter<"analisissifathujan"> | Date | string
    updatedAt?: DateTimeFilter<"analisissifathujan"> | Date | string
  }

  export type analisissifathujanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisissifathujanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: analisissifathujanWhereInput | analisissifathujanWhereInput[]
    OR?: analisissifathujanWhereInput[]
    NOT?: analisissifathujanWhereInput | analisissifathujanWhereInput[]
    name?: DateTimeFilter<"analisissifathujan"> | Date | string
    foto?: StringFilter<"analisissifathujan"> | string
    url?: StringFilter<"analisissifathujan"> | string
    createdAt?: DateTimeFilter<"analisissifathujan"> | Date | string
    updatedAt?: DateTimeFilter<"analisissifathujan"> | Date | string
  }, "id">

  export type analisissifathujanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: analisissifathujanCountOrderByAggregateInput
    _avg?: analisissifathujanAvgOrderByAggregateInput
    _max?: analisissifathujanMaxOrderByAggregateInput
    _min?: analisissifathujanMinOrderByAggregateInput
    _sum?: analisissifathujanSumOrderByAggregateInput
  }

  export type analisissifathujanScalarWhereWithAggregatesInput = {
    AND?: analisissifathujanScalarWhereWithAggregatesInput | analisissifathujanScalarWhereWithAggregatesInput[]
    OR?: analisissifathujanScalarWhereWithAggregatesInput[]
    NOT?: analisissifathujanScalarWhereWithAggregatesInput | analisissifathujanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"analisissifathujan"> | number
    name?: DateTimeWithAggregatesFilter<"analisissifathujan"> | Date | string
    foto?: StringWithAggregatesFilter<"analisissifathujan"> | string
    url?: StringWithAggregatesFilter<"analisissifathujan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"analisissifathujan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"analisissifathujan"> | Date | string
  }

  export type prakiraancurahhujanWhereInput = {
    AND?: prakiraancurahhujanWhereInput | prakiraancurahhujanWhereInput[]
    OR?: prakiraancurahhujanWhereInput[]
    NOT?: prakiraancurahhujanWhereInput | prakiraancurahhujanWhereInput[]
    id?: IntFilter<"prakiraancurahhujan"> | number
    name?: DateTimeFilter<"prakiraancurahhujan"> | Date | string
    foto?: StringFilter<"prakiraancurahhujan"> | string
    url?: StringFilter<"prakiraancurahhujan"> | string
    createdAt?: DateTimeFilter<"prakiraancurahhujan"> | Date | string
    updatedAt?: DateTimeFilter<"prakiraancurahhujan"> | Date | string
  }

  export type prakiraancurahhujanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prakiraancurahhujanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: prakiraancurahhujanWhereInput | prakiraancurahhujanWhereInput[]
    OR?: prakiraancurahhujanWhereInput[]
    NOT?: prakiraancurahhujanWhereInput | prakiraancurahhujanWhereInput[]
    name?: DateTimeFilter<"prakiraancurahhujan"> | Date | string
    foto?: StringFilter<"prakiraancurahhujan"> | string
    url?: StringFilter<"prakiraancurahhujan"> | string
    createdAt?: DateTimeFilter<"prakiraancurahhujan"> | Date | string
    updatedAt?: DateTimeFilter<"prakiraancurahhujan"> | Date | string
  }, "id">

  export type prakiraancurahhujanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: prakiraancurahhujanCountOrderByAggregateInput
    _avg?: prakiraancurahhujanAvgOrderByAggregateInput
    _max?: prakiraancurahhujanMaxOrderByAggregateInput
    _min?: prakiraancurahhujanMinOrderByAggregateInput
    _sum?: prakiraancurahhujanSumOrderByAggregateInput
  }

  export type prakiraancurahhujanScalarWhereWithAggregatesInput = {
    AND?: prakiraancurahhujanScalarWhereWithAggregatesInput | prakiraancurahhujanScalarWhereWithAggregatesInput[]
    OR?: prakiraancurahhujanScalarWhereWithAggregatesInput[]
    NOT?: prakiraancurahhujanScalarWhereWithAggregatesInput | prakiraancurahhujanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"prakiraancurahhujan"> | number
    name?: DateTimeWithAggregatesFilter<"prakiraancurahhujan"> | Date | string
    foto?: StringWithAggregatesFilter<"prakiraancurahhujan"> | string
    url?: StringWithAggregatesFilter<"prakiraancurahhujan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"prakiraancurahhujan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"prakiraancurahhujan"> | Date | string
  }

  export type haritanpahujanWhereInput = {
    AND?: haritanpahujanWhereInput | haritanpahujanWhereInput[]
    OR?: haritanpahujanWhereInput[]
    NOT?: haritanpahujanWhereInput | haritanpahujanWhereInput[]
    id?: IntFilter<"haritanpahujan"> | number
    name?: DateTimeFilter<"haritanpahujan"> | Date | string
    foto?: StringFilter<"haritanpahujan"> | string
    url?: StringFilter<"haritanpahujan"> | string
    createdAt?: DateTimeFilter<"haritanpahujan"> | Date | string
    updatedAt?: DateTimeFilter<"haritanpahujan"> | Date | string
  }

  export type haritanpahujanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type haritanpahujanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: haritanpahujanWhereInput | haritanpahujanWhereInput[]
    OR?: haritanpahujanWhereInput[]
    NOT?: haritanpahujanWhereInput | haritanpahujanWhereInput[]
    name?: DateTimeFilter<"haritanpahujan"> | Date | string
    foto?: StringFilter<"haritanpahujan"> | string
    url?: StringFilter<"haritanpahujan"> | string
    createdAt?: DateTimeFilter<"haritanpahujan"> | Date | string
    updatedAt?: DateTimeFilter<"haritanpahujan"> | Date | string
  }, "id">

  export type haritanpahujanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: haritanpahujanCountOrderByAggregateInput
    _avg?: haritanpahujanAvgOrderByAggregateInput
    _max?: haritanpahujanMaxOrderByAggregateInput
    _min?: haritanpahujanMinOrderByAggregateInput
    _sum?: haritanpahujanSumOrderByAggregateInput
  }

  export type haritanpahujanScalarWhereWithAggregatesInput = {
    AND?: haritanpahujanScalarWhereWithAggregatesInput | haritanpahujanScalarWhereWithAggregatesInput[]
    OR?: haritanpahujanScalarWhereWithAggregatesInput[]
    NOT?: haritanpahujanScalarWhereWithAggregatesInput | haritanpahujanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"haritanpahujan"> | number
    name?: DateTimeWithAggregatesFilter<"haritanpahujan"> | Date | string
    foto?: StringWithAggregatesFilter<"haritanpahujan"> | string
    url?: StringWithAggregatesFilter<"haritanpahujan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"haritanpahujan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"haritanpahujan"> | Date | string
  }

  export type normalmusimWhereInput = {
    AND?: normalmusimWhereInput | normalmusimWhereInput[]
    OR?: normalmusimWhereInput[]
    NOT?: normalmusimWhereInput | normalmusimWhereInput[]
    id?: IntFilter<"normalmusim"> | number
    name?: DateTimeFilter<"normalmusim"> | Date | string
    foto?: StringFilter<"normalmusim"> | string
    url?: StringFilter<"normalmusim"> | string
    createdAt?: DateTimeFilter<"normalmusim"> | Date | string
    updatedAt?: DateTimeFilter<"normalmusim"> | Date | string
  }

  export type normalmusimOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type normalmusimWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: normalmusimWhereInput | normalmusimWhereInput[]
    OR?: normalmusimWhereInput[]
    NOT?: normalmusimWhereInput | normalmusimWhereInput[]
    name?: DateTimeFilter<"normalmusim"> | Date | string
    foto?: StringFilter<"normalmusim"> | string
    url?: StringFilter<"normalmusim"> | string
    createdAt?: DateTimeFilter<"normalmusim"> | Date | string
    updatedAt?: DateTimeFilter<"normalmusim"> | Date | string
  }, "id">

  export type normalmusimOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: normalmusimCountOrderByAggregateInput
    _avg?: normalmusimAvgOrderByAggregateInput
    _max?: normalmusimMaxOrderByAggregateInput
    _min?: normalmusimMinOrderByAggregateInput
    _sum?: normalmusimSumOrderByAggregateInput
  }

  export type normalmusimScalarWhereWithAggregatesInput = {
    AND?: normalmusimScalarWhereWithAggregatesInput | normalmusimScalarWhereWithAggregatesInput[]
    OR?: normalmusimScalarWhereWithAggregatesInput[]
    NOT?: normalmusimScalarWhereWithAggregatesInput | normalmusimScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"normalmusim"> | number
    name?: DateTimeWithAggregatesFilter<"normalmusim"> | Date | string
    foto?: StringWithAggregatesFilter<"normalmusim"> | string
    url?: StringWithAggregatesFilter<"normalmusim"> | string
    createdAt?: DateTimeWithAggregatesFilter<"normalmusim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"normalmusim"> | Date | string
  }

  export type kritiksaranWhereInput = {
    AND?: kritiksaranWhereInput | kritiksaranWhereInput[]
    OR?: kritiksaranWhereInput[]
    NOT?: kritiksaranWhereInput | kritiksaranWhereInput[]
    id?: IntFilter<"kritiksaran"> | number
    nama?: StringFilter<"kritiksaran"> | string
    email?: StringFilter<"kritiksaran"> | string
    nohp?: StringFilter<"kritiksaran"> | string
    kritik?: StringFilter<"kritiksaran"> | string
    saran?: StringFilter<"kritiksaran"> | string
    createAt?: DateTimeFilter<"kritiksaran"> | Date | string
    updatedAt?: DateTimeFilter<"kritiksaran"> | Date | string
  }

  export type kritiksaranOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    nohp?: SortOrder
    kritik?: SortOrder
    saran?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type kritiksaranWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kritiksaranWhereInput | kritiksaranWhereInput[]
    OR?: kritiksaranWhereInput[]
    NOT?: kritiksaranWhereInput | kritiksaranWhereInput[]
    nama?: StringFilter<"kritiksaran"> | string
    email?: StringFilter<"kritiksaran"> | string
    nohp?: StringFilter<"kritiksaran"> | string
    kritik?: StringFilter<"kritiksaran"> | string
    saran?: StringFilter<"kritiksaran"> | string
    createAt?: DateTimeFilter<"kritiksaran"> | Date | string
    updatedAt?: DateTimeFilter<"kritiksaran"> | Date | string
  }, "id">

  export type kritiksaranOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    nohp?: SortOrder
    kritik?: SortOrder
    saran?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    _count?: kritiksaranCountOrderByAggregateInput
    _avg?: kritiksaranAvgOrderByAggregateInput
    _max?: kritiksaranMaxOrderByAggregateInput
    _min?: kritiksaranMinOrderByAggregateInput
    _sum?: kritiksaranSumOrderByAggregateInput
  }

  export type kritiksaranScalarWhereWithAggregatesInput = {
    AND?: kritiksaranScalarWhereWithAggregatesInput | kritiksaranScalarWhereWithAggregatesInput[]
    OR?: kritiksaranScalarWhereWithAggregatesInput[]
    NOT?: kritiksaranScalarWhereWithAggregatesInput | kritiksaranScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kritiksaran"> | number
    nama?: StringWithAggregatesFilter<"kritiksaran"> | string
    email?: StringWithAggregatesFilter<"kritiksaran"> | string
    nohp?: StringWithAggregatesFilter<"kritiksaran"> | string
    kritik?: StringWithAggregatesFilter<"kritiksaran"> | string
    saran?: StringWithAggregatesFilter<"kritiksaran"> | string
    createAt?: DateTimeWithAggregatesFilter<"kritiksaran"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"kritiksaran"> | Date | string
  }

  export type cuacabesokWhereInput = {
    AND?: cuacabesokWhereInput | cuacabesokWhereInput[]
    OR?: cuacabesokWhereInput[]
    NOT?: cuacabesokWhereInput | cuacabesokWhereInput[]
    id?: IntFilter<"cuacabesok"> | number
    name?: DateTimeFilter<"cuacabesok"> | Date | string
    foto?: StringFilter<"cuacabesok"> | string
    url?: StringFilter<"cuacabesok"> | string
    createdAt?: DateTimeFilter<"cuacabesok"> | Date | string
    updatedAt?: DateTimeFilter<"cuacabesok"> | Date | string
  }

  export type cuacabesokOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacabesokWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cuacabesokWhereInput | cuacabesokWhereInput[]
    OR?: cuacabesokWhereInput[]
    NOT?: cuacabesokWhereInput | cuacabesokWhereInput[]
    name?: DateTimeFilter<"cuacabesok"> | Date | string
    foto?: StringFilter<"cuacabesok"> | string
    url?: StringFilter<"cuacabesok"> | string
    createdAt?: DateTimeFilter<"cuacabesok"> | Date | string
    updatedAt?: DateTimeFilter<"cuacabesok"> | Date | string
  }, "id">

  export type cuacabesokOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cuacabesokCountOrderByAggregateInput
    _avg?: cuacabesokAvgOrderByAggregateInput
    _max?: cuacabesokMaxOrderByAggregateInput
    _min?: cuacabesokMinOrderByAggregateInput
    _sum?: cuacabesokSumOrderByAggregateInput
  }

  export type cuacabesokScalarWhereWithAggregatesInput = {
    AND?: cuacabesokScalarWhereWithAggregatesInput | cuacabesokScalarWhereWithAggregatesInput[]
    OR?: cuacabesokScalarWhereWithAggregatesInput[]
    NOT?: cuacabesokScalarWhereWithAggregatesInput | cuacabesokScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cuacabesok"> | number
    name?: DateTimeWithAggregatesFilter<"cuacabesok"> | Date | string
    foto?: StringWithAggregatesFilter<"cuacabesok"> | string
    url?: StringWithAggregatesFilter<"cuacabesok"> | string
    createdAt?: DateTimeWithAggregatesFilter<"cuacabesok"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cuacabesok"> | Date | string
  }

  export type peringatandiniWhereInput = {
    AND?: peringatandiniWhereInput | peringatandiniWhereInput[]
    OR?: peringatandiniWhereInput[]
    NOT?: peringatandiniWhereInput | peringatandiniWhereInput[]
    id?: IntFilter<"peringatandini"> | number
    tanggal?: DateTimeFilter<"peringatandini"> | Date | string
    peringatan?: StringFilter<"peringatandini"> | string
    createdAt?: DateTimeFilter<"peringatandini"> | Date | string
    updatedAt?: DateTimeFilter<"peringatandini"> | Date | string
  }

  export type peringatandiniOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    peringatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type peringatandiniWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: peringatandiniWhereInput | peringatandiniWhereInput[]
    OR?: peringatandiniWhereInput[]
    NOT?: peringatandiniWhereInput | peringatandiniWhereInput[]
    tanggal?: DateTimeFilter<"peringatandini"> | Date | string
    peringatan?: StringFilter<"peringatandini"> | string
    createdAt?: DateTimeFilter<"peringatandini"> | Date | string
    updatedAt?: DateTimeFilter<"peringatandini"> | Date | string
  }, "id">

  export type peringatandiniOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    peringatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: peringatandiniCountOrderByAggregateInput
    _avg?: peringatandiniAvgOrderByAggregateInput
    _max?: peringatandiniMaxOrderByAggregateInput
    _min?: peringatandiniMinOrderByAggregateInput
    _sum?: peringatandiniSumOrderByAggregateInput
  }

  export type peringatandiniScalarWhereWithAggregatesInput = {
    AND?: peringatandiniScalarWhereWithAggregatesInput | peringatandiniScalarWhereWithAggregatesInput[]
    OR?: peringatandiniScalarWhereWithAggregatesInput[]
    NOT?: peringatandiniScalarWhereWithAggregatesInput | peringatandiniScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"peringatandini"> | number
    tanggal?: DateTimeWithAggregatesFilter<"peringatandini"> | Date | string
    peringatan?: StringWithAggregatesFilter<"peringatandini"> | string
    createdAt?: DateTimeWithAggregatesFilter<"peringatandini"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"peringatandini"> | Date | string
  }

  export type ImageCreateInput = {
    name: string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    name: string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManyInput = {
    id?: number
    name: string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuletinTableCreateInput = {
    name: string
    buletin: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuletinTableUncheckedCreateInput = {
    id?: number
    name: string
    buletin: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuletinTableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buletin?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuletinTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buletin?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuletinTableCreateManyInput = {
    id?: number
    name: string
    buletin: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuletinTableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    buletin?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuletinTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buletin?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beritaCreateInput = {
    judul: string
    tanggal: Date | string
    isi: string
    gambar: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type beritaUncheckedCreateInput = {
    id?: number
    judul: string
    tanggal: Date | string
    isi: string
    gambar: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type beritaUpdateInput = {
    judul?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    isi?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beritaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    isi?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beritaCreateManyInput = {
    id?: number
    judul: string
    tanggal: Date | string
    isi: string
    gambar: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type beritaUpdateManyMutationInput = {
    judul?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    isi?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beritaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    isi?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pegawaiCreateInput = {
    nama: string
    nip: string
    pangkat: string
    jabatan: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pegawaiUncheckedCreateInput = {
    id?: number
    nama: string
    nip: string
    pangkat: string
    jabatan: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pegawaiUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    pangkat?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pegawaiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    pangkat?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pegawaiCreateManyInput = {
    id?: number
    nama: string
    nip: string
    pangkat: string
    jabatan: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pegawaiUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    pangkat?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pegawaiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    pangkat?: StringFieldUpdateOperationsInput | string
    jabatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacahariiniCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cuacahariiniUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cuacahariiniUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacahariiniUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacahariiniCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cuacahariiniUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacahariiniUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tourismCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tourismUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tourismUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tourismUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tourismCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tourismUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tourismUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisiscurahhujanCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisiscurahhujanUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisiscurahhujanUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisiscurahhujanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisiscurahhujanCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisiscurahhujanUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisiscurahhujanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisissifathujanCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisissifathujanUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisissifathujanUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisissifathujanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisissifathujanCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisissifathujanUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisissifathujanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prakiraancurahhujanCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type prakiraancurahhujanUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type prakiraancurahhujanUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prakiraancurahhujanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prakiraancurahhujanCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type prakiraancurahhujanUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prakiraancurahhujanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type haritanpahujanCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type haritanpahujanUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type haritanpahujanUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type haritanpahujanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type haritanpahujanCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type haritanpahujanUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type haritanpahujanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type normalmusimCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type normalmusimUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type normalmusimUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type normalmusimUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type normalmusimCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type normalmusimUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type normalmusimUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kritiksaranCreateInput = {
    nama: string
    email: string
    nohp: string
    kritik: string
    saran: string
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type kritiksaranUncheckedCreateInput = {
    id?: number
    nama: string
    email: string
    nohp: string
    kritik: string
    saran: string
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type kritiksaranUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nohp?: StringFieldUpdateOperationsInput | string
    kritik?: StringFieldUpdateOperationsInput | string
    saran?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kritiksaranUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nohp?: StringFieldUpdateOperationsInput | string
    kritik?: StringFieldUpdateOperationsInput | string
    saran?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kritiksaranCreateManyInput = {
    id?: number
    nama: string
    email: string
    nohp: string
    kritik: string
    saran: string
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type kritiksaranUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nohp?: StringFieldUpdateOperationsInput | string
    kritik?: StringFieldUpdateOperationsInput | string
    saran?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kritiksaranUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nohp?: StringFieldUpdateOperationsInput | string
    kritik?: StringFieldUpdateOperationsInput | string
    saran?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacabesokCreateInput = {
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cuacabesokUncheckedCreateInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cuacabesokUpdateInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacabesokUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacabesokCreateManyInput = {
    id?: number
    name: Date | string
    foto: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cuacabesokUpdateManyMutationInput = {
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cuacabesokUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type peringatandiniCreateInput = {
    tanggal: Date | string
    peringatan: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type peringatandiniUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    peringatan: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type peringatandiniUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    peringatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type peringatandiniUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    peringatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type peringatandiniCreateManyInput = {
    id?: number
    tanggal: Date | string
    peringatan: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type peringatandiniUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    peringatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type peringatandiniUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    peringatan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BuletinTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    buletin?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuletinTableAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuletinTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    buletin?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuletinTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    buletin?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuletinTableSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type beritaCountOrderByAggregateInput = {
    id?: SortOrder
    judul?: SortOrder
    tanggal?: SortOrder
    isi?: SortOrder
    gambar?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type beritaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type beritaMaxOrderByAggregateInput = {
    id?: SortOrder
    judul?: SortOrder
    tanggal?: SortOrder
    isi?: SortOrder
    gambar?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type beritaMinOrderByAggregateInput = {
    id?: SortOrder
    judul?: SortOrder
    tanggal?: SortOrder
    isi?: SortOrder
    gambar?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type beritaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pegawaiCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    nip?: SortOrder
    pangkat?: SortOrder
    jabatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pegawaiAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pegawaiMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    nip?: SortOrder
    pangkat?: SortOrder
    jabatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pegawaiMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    nip?: SortOrder
    pangkat?: SortOrder
    jabatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pegawaiSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cuacahariiniCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacahariiniAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cuacahariiniMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacahariiniMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacahariiniSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tourismCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tourismAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tourismMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tourismMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tourismSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type analisiscurahhujanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisiscurahhujanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type analisiscurahhujanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisiscurahhujanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisiscurahhujanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type analisissifathujanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisissifathujanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type analisissifathujanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisissifathujanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type analisissifathujanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type prakiraancurahhujanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prakiraancurahhujanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type prakiraancurahhujanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prakiraancurahhujanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prakiraancurahhujanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type haritanpahujanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type haritanpahujanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type haritanpahujanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type haritanpahujanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type haritanpahujanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type normalmusimCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type normalmusimAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type normalmusimMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type normalmusimMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type normalmusimSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kritiksaranCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    nohp?: SortOrder
    kritik?: SortOrder
    saran?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type kritiksaranAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kritiksaranMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    nohp?: SortOrder
    kritik?: SortOrder
    saran?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type kritiksaranMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    nohp?: SortOrder
    kritik?: SortOrder
    saran?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type kritiksaranSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cuacabesokCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacabesokAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cuacabesokMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacabesokMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    foto?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cuacabesokSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type peringatandiniCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    peringatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type peringatandiniAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type peringatandiniMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    peringatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type peringatandiniMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    peringatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type peringatandiniSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ImageDefaultArgs instead
     */
    export type ImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuletinTableDefaultArgs instead
     */
    export type BuletinTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuletinTableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use beritaDefaultArgs instead
     */
    export type beritaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = beritaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pegawaiDefaultArgs instead
     */
    export type pegawaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pegawaiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cuacahariiniDefaultArgs instead
     */
    export type cuacahariiniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cuacahariiniDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tourismDefaultArgs instead
     */
    export type tourismArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tourismDefaultArgs<ExtArgs>
    /**
     * @deprecated Use analisiscurahhujanDefaultArgs instead
     */
    export type analisiscurahhujanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = analisiscurahhujanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use analisissifathujanDefaultArgs instead
     */
    export type analisissifathujanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = analisissifathujanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prakiraancurahhujanDefaultArgs instead
     */
    export type prakiraancurahhujanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prakiraancurahhujanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use haritanpahujanDefaultArgs instead
     */
    export type haritanpahujanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = haritanpahujanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use normalmusimDefaultArgs instead
     */
    export type normalmusimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = normalmusimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kritiksaranDefaultArgs instead
     */
    export type kritiksaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kritiksaranDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cuacabesokDefaultArgs instead
     */
    export type cuacabesokArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cuacabesokDefaultArgs<ExtArgs>
    /**
     * @deprecated Use peringatandiniDefaultArgs instead
     */
    export type peringatandiniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = peringatandiniDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}